<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">Analizadores Sint√°cticos LL(1) | Lenguajes y Compiladores</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jisbruzzi.github.io/docs/teoricas/analisis-sintactico/LL1"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Analizadores Sint√°cticos LL(1) | Lenguajes y Compiladores"><meta data-react-helmet="true" name="description" content="El an√°lisis sint√°ctico LL(1) utiliza una pila explicita en vez de llamadas recursivas para efectuar el an√°lisis sint√°ctico. Una gram√°tica LL(1) no tiene recursividad por la izquierda y no es ambigua."><meta data-react-helmet="true" property="og:description" content="El an√°lisis sint√°ctico LL(1) utiliza una pila explicita en vez de llamadas recursivas para efectuar el an√°lisis sint√°ctico. Una gram√°tica LL(1) no tiene recursividad por la izquierda y no es ambigua."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://jisbruzzi.github.io/docs/teoricas/analisis-sintactico/LL1"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/teoricas/analisis-sintactico/LL1" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/teoricas/analisis-sintactico/LL1" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.a91fdf40.css">
<link rel="preload" href="/assets/js/runtime~main.d9c9bf77.js" as="script">
<link rel="preload" href="/assets/js/main.8c8b089d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Lenguajes y Compiladores</b></a><a class="navbar__item navbar__link" href="/docs/labs/intro">Laboratorios</a><a class="navbar__item navbar__link" href="/docs/practicas/intro">Pr√°cticas</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/teoricas/intro">Te√≥ricas</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/docs/labs/intro_teorica">este cuatri</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link navbar__link--active" href="/docs/teoricas/analisis-sintactico/LL1">este cuatri</a></li><li><a class="dropdown__link" href="/docs/2021_2/teoricas/analisis-sintactico/LL1">2021_2</a></li></ul></div><a href="https://github.com/compiladores" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">üåú</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">üåû</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/teoricas/intro">Compiladores</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/teoricas/proc-lenguaje">Procesadores de Lenguaje</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-lexico</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">analisis-sintactico</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/teoricas/analisis-sintactico/intro">Parsing</a></li><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/teoricas/analisis-sintactico/LL1">Analizadores Sint√°cticos LL(1)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/teoricas/analisis-sintactico/analizadores-sintacticos-ascendentes">Analizadores Sint√°cticos LR</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/teoricas/analisis-sintactico/analisis-sintactico-lr">Analizadores Sint√°cticos</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/teoricas/analisis-sintactico/generadores">Generadores de Analizadores Sint√°cticos</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-semantico</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/teoricas/bibliografia">Bibliografia</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">generacion-ir</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/teoricas/bibliografia">Bibliografia</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><span class="badge badge--secondary">Version: este cuatri</span><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1>Analizadores Sint√°cticos LL(1)</h1></header><p>El an√°lisis sint√°ctico LL(1) utiliza una pila explicita en vez de llamadas recursivas para efectuar el an√°lisis sint√°ctico. Una gram√°tica LL(1) <strong>no tiene recursividad por la izquierda y no es ambigua</strong>.</p><p>Entonces antes de armar el parser se debe verificar que la gram√°tica sea LL(1) o se transforma la gram√°tica con la que se est√° trabajando en LL(1) mediante la aplicaci√≥n de las siguientes t√©cnicas:</p><ul><li><p>Eliminaci√≥n de la recursividad por Izquierda</p></li><li><p>Eliminaci√≥n de ambig√ºedad</p></li><li><p>Un analizador sint√°ctico descendente comienza a insertar el s√≠mbolo inicial sobre la pila. <strong>Acepta</strong> una cadena de entrada, si, despu√©s de una serie de acciones, la pila y la entrada se quedan vac√≠as.</p></li><li><p>Un analizador sint√°ctico descendente realiza su an√°lisis al reemplazar un no terminal en la parte superior de la pila por una de las elecciones en la regla gramatical (en BNF) para ese no terminal. Realiza esto con miras a producir el token de entrada actual en la parte superior de la pila de an√°lisis sint√°ctico, de donde ha reconocido el token de entrada y puede descartarlo tanto de la pila como de la entrada. Estas dos acciones,</p><ol><li><p><strong>Reemplazar</strong> un no terminal A en la parte superior de la pila mediante una cadena Œ± utilizando la selecci√≥n de la regla gramatical A-&gt;alpha, y</p></li><li><p>Hacer <strong>concordar</strong> un token en la parte superior de la pila con el siguiente token de entrada.</p></li></ol></li></ul><p>Son las dos acciones b√°sicas de un analizador sint√°ctico descendente.</p><ul><li>La primera acci√≥n se llama <strong>generar</strong>.</li></ul><ul><li>La segunda acci√≥n hace <strong>concordar</strong> a un token en la parte superior de la pila con el siguiente token en la entrada (y los desecha a ambos sac√°ndolos de la pila y avanzando a la entrada); indicamos esta acci√≥n indicando la palabra <strong>match</strong>.</li></ul><p>Es importante advertir que en la acci√≥n <strong>generar</strong>, la cadena de reemplazo Œ± se debe insertar en reversa en la pila (ya que eso asegurara que la cadena Œ± arribara a la parte superior de la pila en el orden de izquierda a derecha).</p><ol><li><p>Ejemplo</p><p>Sea la gram√°tica:</p></li></ol><p>S-&gt;(S)S | Œµ</p><table><thead><tr><th></th><th>pila</th><th>entrada</th><th>acci√≥n</th><th></th></tr></thead><tbody><tr><td>1</td><td>$S</td><td>()$</td><td>S-&gt;(S)S</td><td></td></tr><tr><td>2</td><td>$S)S(</td><td>()$</td><td>match</td><td></td></tr><tr><td>3</td><td>$S)S</td><td>)$</td><td>S-&gt;Œµ</td><td></td></tr><tr><td>4</td><td>$S)</td><td>)$</td><td>match</td><td></td></tr><tr><td>5</td><td>$S</td><td>$</td><td>S-&gt;Œµ</td><td></td></tr><tr><td>6</td><td>$</td><td>$</td><td>aceptar</td><td></td></tr></tbody></table><p>Lo que se realiz√≥, es justamente la derivaci√≥n:</p><p>   S -&gt; ( S ) S -&gt; ( ) S [S -&gt; Œµ] -&gt; ( ) [S -&gt; Œµ]</p><p>Tabla de parsing:</p><table><thead><tr><th>M[N,T]</th><th>(</th><th>)</th><th>S</th></tr></thead><tbody><tr><td>S</td><td>S-&gt;(S)S</td><td>S-&gt;Œµ</td><td>S-&gt;Œµ</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="el-algoritmo"></a>El Algoritmo<a class="hash-link" href="#el-algoritmo" title="Direct link to heading">#</a></h3><p>Para armar un parser LL(1) es necesario cumplir con un conjuntos de pasos. Dado una gram√°tica libre de contexto a la que se quiere construir un analizador sint√°ctico LL(1), es necesario:</p><ul><li>Eliminar la recursi√≥n por izquierda de la gram√°tica</li><li>Factorizar por la Izquierda la gram√°tica</li><li>Construir el conjunto de PRIMEROS</li><li>Construir el Conjunto de SIGUIENTES</li><li>Construir la tabla de Parsing</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="eliminaci√≥n-por-recursi√≥n-por-la-izquierda-y-factorizaci√≥n-por-la-izquierda"></a>Eliminaci√≥n por recursi√≥n por la izquierda y factorizaci√≥n por la izquierda<a class="hash-link" href="#eliminaci√≥n-por-recursi√≥n-por-la-izquierda-y-factorizaci√≥n-por-la-izquierda" title="Direct link to heading">#</a></h3><p>   ¬øQue es la recursi√≥n por izquierda en una gram√°tica?</p><p>   A ‚Üí A Œ± | Œ≤</p><p>   Donde Œ± y Œ≤ son cadenas de terminales y no terminales , y Œ≤ no comienza con A. Entonces A ‚Üí Œ≤ es el caso base, mientras que A ‚Üí A Œ± es el caso recursivo.</p><ul><li>La eliminaci√≥n de recursi√≥n a la izquierda no cambia el lenguaje que se est√° reconocienndo.</li></ul><ol><li><p>Eliminaci√≥n de recursi√≥n por la Izquierda simple</p><p>Para eliminar la recursi√≥n por izquierda se reescriben las reglas gramaticales divididas en dos</p><p>Sea la gram√°tica:</p><p>‚Äã               A ‚Üí AŒ± | Œ≤</p><p>una que primero genera Œ≤ y la otra que genere las repeticiones de Œ± utilizando recursividad por derecha :</p><p>‚Äã               A ‚Üí Œ≤ A&#x27; </p><p>‚Äã               A&#x27; ‚Üí Œ± A&#x27; | Œµ</p><p>Otro ejemplo :</p></li></ol><p>Sea la gram√°tica :</p><p>‚Äã                    exp ‚Üí exp opsuma term | term</p><p>Se genera seg√∫n la regla la siguiente gram√°tica:</p><p>‚Äã                    exp ‚Üí term exp&#x27; </p><p>‚Äã                     exp&#x27; ‚Üí opsuma term exp&#x27; | Œµ</p><p>‚Äã      </p><ol start="2"><li>Eliminaci√≥n  Recursi√≥n por la Izquierda Inmediata General</li></ol><p>Sean las siguientes producciones:</p><p>‚Äã                              A ‚Üí A Œ±<sub>1</sub>| A Œ±<sub>2</sub> |‚Ä¶ | A Œ±<sub>n</sub> | Œ≤<sub>1</sub> | Œ≤<sub>2</sub> | ‚Ä¶ | Œ≤<sub>m</sub></p><p>Donde ninguna de la Œ≤ comienza con A. En este caso la soluci√≥n es semejante al caso simple:</p><p>‚Äã                               A ‚Üí Œ≤<sub>1</sub> A&#x27;| Œ≤<sub>2</sub>A&#x27; | ‚Ä¶ | Œ≤<sub>m</sub>A&#x27; </p><p>‚Äã                               A&#x27; ‚Üí Œ±<sub>1</sub>A&#x27;| Œ±<sub>2</sub>A&#x27; |‚Ä¶ | Œ±<sub>n</sub> A&#x27; | Œµ</p><p>Ejemplo:</p><p>‚Äã                             exp ‚Üí exp + term | exp - term | term</p><p>Aplicando la regla general inmediata:</p><p>‚Äã      </p><p>‚Äã                             exp ‚Üí term exp&#x27; </p><p>‚Äã                             exp&#x27; ‚Üí + term exp&#x27; | - term exp&#x27; | Œµ</p><p>‚Äã      </p><ol start="3"><li>Eliminaci√≥n de Recursi√≥n por Izquierda General:</li></ol><p>A continuaci√≥n se propone un algoritmo que elimina de forma sistem√°tica la recursividad por la izquierda de una gram√°tica. Esto se garantiza si la gram√°tica no tiene ciclos ( derivaciones de A ‚Üí +A) o producciones Œµ. Si los hubiera estos pueden eliminarse de la gramatica.</p><ul><li>El algoritmo:</li><li>ENTRADA: La gram√°tica G sin ciclos ni producciones Œµ().</li><li>SALIDA: Una gram√°tica equivalente sin recursividad por la izquierda.</li><li>M√âTODO:
</li></ul><p>ordenar los nodos no terminales de cierta forma A<sub>1</sub>, ‚Ä¶ A<sub>n</sub> </p><p>for ( cada i de 1 a n){
for ( cada j de 1 a i-1) {
sustituir cada producci√≥n de la forma A<sub>i</sub> ‚Üí A<sub>j</sub>Œ≥ por las producciones A<sub>i</sub> -&gt; Œ¥<sub>1</sub> Œ≥() | ‚Ä¶..| Œ¥<sub>k</sub>Œ≥ en donde A<sub>j</sub> ‚Üí delta<sub>1</sub> | Œ¥<sub>2</sub> | ‚Ä¶.. | Œ¥<sub>k</sub> sean todas producciones A<sub>j</sub> actuales
}
Eliminar la recursividad inmediata por la izquierda entre la producciones A<sub>i</sub>
}</p><ol><li>Ejemplo</li></ol><p>Intentar aplicar el algoritmo general: </p><p>S ‚Üí Aa | b
A ‚Üí Ac | Sd | Œµ</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="factorizaci√≥n"></a>Factorizaci√≥n<a class="hash-link" href="#factorizaci√≥n" title="Direct link to heading">#</a></h3><p>   La factorizaci√≥n por izquierda se requiere cuando dos o m√°s opciones de reglas gramaticales comparten una cadena de prefijo com√∫n:</p><p>   A ‚Üí Œ±Œ≤ | Œ±Œ≥</p><p>   Un analizador sint√°ctico LL(1) no puede distinguir entre las opciones de producci√≥n en una sustituci√≥n de esta clase. Para solucionar esto es factorizar la Œ± por la izquierda y volver a escribir la regla como dos reglas:</p><p>   A ‚Üí Œ± A&#x27; </p><p>   A&#x27; ‚Üí Œ≤ | Œ≥</p><p>   Otros ejemplos:</p><p>   secuencia-sent ‚Üí sent ; secuencia-sent | sent </p><p>   sent ‚Üí s</p><p>   Al aplicar la factorizaci√≥n se obtiene dos reglas:</p><p>   secuencia-sent ‚Üí sent secuencia-sent&#x27; </p><p>   secuencia-sent&#x27; ‚Üí  ; | Œµ</p><p>   La gram√°tica resultante :</p><p>   secuencia-sent ‚Üí sent secuencia-sent&#x27; </p><p>   secuencia-sent&#x27; ‚Üí  ; | Œµ </p><p>   sent ‚Üí s</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="primero-y-siguiente"></a>PRIMERO y SIGUIENTE<a class="hash-link" href="#primero-y-siguiente" title="Direct link to heading">#</a></h3><p>(Aho:p221, lou:p168, Coo:p )</p><p>Si una gram√°tica posee un conjunto de producciones en la cual no es posible determinar a ciencia cierta cual es la producci√≥n seleccionada por la cual se est√° derivando entonces, en la construcci√≥n de analizadores sint√°cticos descendientes ( y tambi√©n ascendentes) se utilizan dos funciones auxiliares asociadas con la gram√°tica G, PRIMERO() y SIGUIENTE():</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="primero-o-first"></a>Primero o First<a class="hash-link" href="#primero-o-first" title="Direct link to heading">#</a></h3><p>PRIMERO(Œ±), donde Œ± es cualquier cadena de s√≠mbolos gramaticales, como el conjunto de terminales que empiezan las cadenas derivadas a partir de Œ±. C√≥mo se calcula el conjunto PRIMERO o First:</p><p>Si X es un s√≠mbolo de la gram√°tica ( un terminal o un no terminal) o Œµ, entonces el conjunto <strong>Primero(X)</strong>, compuesto de terminales, y posiblemente de Œµ, se define de la siguiente manera:</p><ol><li>Si X es un terminal o Œµ, entonces Primero(X)={X}.</li><li>Si X es no terminal, entonces para cada selecci√≥n de producci√≥n X -&gt; X<sub>1</sub> X<sub>2</sub> ‚Ä¶ X<sub>n</sub>, Primero(X) contiene Primero{X<sub>1</sub>} - Œµ.</li></ol><ul><li>Si tambi√©n para cualquier i&lt;n, todos los conjuntos Primeros(X<sub>1</sub>) -&gt; Primero(x<sub>i</sub>, contienen Œµ, entonces Primero(X)=Primero(X<sub>1</sub>) -Œµ.</li><li>Si todos los conjuntos Primer(X<sub>i</sub>) contiene Œµ, entonces Primero(X) contiene Œµ.</li></ul><ol start="3"><li><p>El conjunto de PRIMEROS son aquellos caracteres que van a identificar en que producci√≥n estoy de las varias producciones de una gram√°tica.</p><p>Algunos ejemplos de la aplicaci√≥n de estas reglas :</p><p>A ‚Üí tB     entonces PRIMERO(A)={t} </p><p>A ‚Üí BŒ≤¬†   entonces tambi√©n PRIMERO(A)=PRIMERO(B)</p></li></ol><ol><li><p>Ejemplo</p><p>A ‚Üí aC </p><p>B ‚Üí Œµ | m </p><p>C ‚Üí Œµ | s | y</p></li></ol><p>‚Äã     </p><p>Otra opci√≥n de ver la gramatica:</p><p>   A ‚Üí aC </p><p>   B ‚Üí Œµ </p><p>   B ‚Üí m </p><p>   C ‚Üí Œµ </p><p>   C‚Üí s</p><p>   Nota: siempre conviene primero obtener los consjuntos primeros de las derivaciones con no terminales:</p><p>   Paso 1: Obtengo las producciones que derivan en no terminales</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>A</td><td>{a}</td></tr><tr><td>B</td><td>{m, Œµ }</td></tr><tr><td>C</td><td>{s, Œµ}</td></tr></tbody></table><p>   Paso 2: De las producciones que derivan en no terminales elijo el primer no terminal y voy a su producci√≥n, hasta alcanzar a un terminal</p><ul><li>En este caso no hay, es el caso m√°s f√°cil</li></ul><ol><li><p>Ejemplo</p><p>S ‚Üí ABCDE </p><p>A ‚Üí a | Œµ</p><p>B ‚Üí b | Œµ</p><p>C ‚Üí c</p><p>D ‚Üí d | Œµ </p><p>E ‚Üí e | Œµ</p><p>Nota: siempre conviene primero obtener los conjuntos primeros de las derivaciones con no terminales:</p><p>Paso 1: Obtengo las producciones que derivan en no terminales</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>S</td><td>{}</td></tr><tr><td>A</td><td>{a,Œµ}</td></tr><tr><td>B</td><td>{b,Œµ}</td></tr><tr><td>C</td><td>{c}</td></tr><tr><td>D</td><td>{d,Œµ}</td></tr><tr><td>E</td><td>{e,Œµ}</td></tr></tbody></table><p>Paso 2: De las producciones que derivan en no terminales elijo el primer no terminal y voy a su producci√≥n, hasta alcanzar a un terminal</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>S</td><td>{a,b,c}</td></tr><tr><td>A</td><td>{a,Œµ}</td></tr><tr><td>B</td><td>{b,Œµ}</td></tr><tr><td>C</td><td>{c}</td></tr><tr><td>D</td><td>{d,Œµ}</td></tr><tr><td>E</td><td>{e,Œµ}</td></tr></tbody></table></li><li><p>Ejemplo</p><p>   exp -&gt; exp opsuma term | term </p><p>   opsuma -&gt; + | - </p><p>   term -&gt; term opmult term | factor </p><p>   opmult -&gt; * </p><p>   factor -&gt; ( exp ) | numero</p><p>   es conveniente separar las producciones que queden de a una:</p></li></ol><table><thead><tr><th>n</th><th>producci√≥n</th></tr></thead><tbody><tr><td>1</td><td>exp          -&gt; exp opsuma term</td></tr><tr><td>2</td><td>exp          -&gt; term</td></tr><tr><td>3</td><td>opsuma       -&gt; +</td></tr><tr><td>4</td><td>opsuma       -&gt; -</td></tr><tr><td>5</td><td>term         -&gt; term opmult term</td></tr><tr><td>6</td><td>term         -&gt; factor</td></tr><tr><td>7</td><td>opmult       -&gt; *</td></tr><tr><td>8</td><td>factor       -&gt; ( exp )</td></tr><tr><td>9</td><td>factor       -&gt; numero</td></tr></tbody></table><p>Nota: siempre conviene primero obtener los conjuntos primeros de las derivaciones con no terminales:</p><p>Paso 1: Obtengo las producciones que derivan en no terminales</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>exp</td><td>{}</td></tr><tr><td>opsum</td><td>{+,-}</td></tr><tr><td>term</td><td>{}</td></tr><tr><td>opmult</td><td>{*}</td></tr><tr><td>factor</td><td>{}</td></tr></tbody></table><p>Paso 2: De las producciones que derivan en no terminales elijo el primer no terminal y voy a su producci√≥n, hasta alcanzar a un terminal</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>exp</td><td>{(,numero}</td></tr><tr><td>opsum</td><td>{+,-}</td></tr><tr><td>term</td><td>{(,numero}</td></tr><tr><td>opmult</td><td>{*}</td></tr><tr><td>factor</td><td>{(,numero}</td></tr></tbody></table><ol><li><p>Ejemplo</p><p>E ‚Üí T E&#x27; </p><p>E&#x27; ‚Üí + T E&#x27; | Œµ </p><p>T ‚Üí F T&#x27; </p><p>T&#x27; ‚Üí * F T&#x27; | Œµ </p><p>F ‚Üí ( E ) | id</p></li></ol><p>   Nota: siempre conviene primero obtener los conjuntos primeros de las derivaciones con terminales:</p><p>   Paso 1: Obtengo las producciones que derivan en no terminales</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>E</td><td></td></tr><tr><td>E&#x27;</td><td>{+, Œµ</td></tr><tr><td>T</td><td></td></tr><tr><td>T&#x27;</td><td>{\*, Œµ}</td></tr><tr><td>F</td><td>{ (, id}</td></tr></tbody></table><p>   Paso 2: De las produccciones que derivan en no terminales elijo el primer no terminal y voy a su producci√≥n, hasta alcanzar a un terminal</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>E</td><td>{ (, id}</td></tr><tr><td>E&#x27;</td><td>{+, Œµ}</td></tr><tr><td>T</td><td>{ (, id}</td></tr><tr><td>T&#x27;</td><td>{\*, Œµ}</td></tr><tr><td>F</td><td>{ (, id}</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="siguiente-o-follow"></a>SIGUIENTE o Follow<a class="hash-link" href="#siguiente-o-follow" title="Direct link to heading">#</a></h4><p>Se define <strong>SIGUIENTE(A), para el no terminal A, como el conjunto de terminales <span class="underline">b</span> que pueden aparecer de inmediato a la derecha de A en cierta forma de frase</strong>. C√≥mo se calcula:</p><p>Dado un nodo <strong>no terminal</strong>, el conjunto <strong>Siguiente(A)</strong>, compuesto de <strong>terminales</strong>, y posiblemente de $ (fin de pila), se define de la siguiente manera:</p><ol><li><p>Si A es el s√≠mbolo inicial, entonces $ est√° en Siguiente(A).</p></li><li><p>Si hay una producci√≥n B ‚Üí Œ± A Œ≥, entonces Primero(Œ≥) - {Œµ} est√° en Siguiente(A).</p></li><li><p>Si hay una producci√≥n B ‚Üí Œ± A Œ≥ tal que Œµ est√° en Primero(Œ≥), entonces Siguiente(A) contiene Siguiente(B).</p></li><li><p>En otras palabras, el siguiente me indica que termin√© con una producci√≥n, es decir cual es el terminal que se encuentra al finalizar esa producci√≥n</p><p>Algunos ejemplos:</p><p>B ‚Üí AC                          entonces SIG(A)=PRIMERO(C)</p><p>S ‚Üí Œ±                             entonces SIG(S)={$}</p><p>B ‚Üí Ac                           entonces el SIG(A)={c}</p><p>B ‚Üí cA                           entonces el SIG(A)= SIG(B) ya que A est√° al final de lo      </p><p>‚Äã                                        que se reemplaza por B</p><p>B ‚Üí Œµ                              entonces SIG(P)={d} </p><p>C ‚Üí PBd</p></li></ol><ol><li><p>Ejemplo 1</p><p>S ‚Üí ABCDE </p><p>A ‚Üí a | Œµ</p><p>B ‚Üí b | Œµ</p><p>C ‚Üí c </p><p>D ‚Üí d | Œµ </p><p>E ‚Üí e | Œµ</p></li></ol><p>   Nota: Se buscan los caracteres que indiquen que una producci√≥n ha terminado.</p><p>   Paso 1: El siguiente del s√≠mbolo inicial es $</p><table><thead><tr><th>no terminal</th><th>Primero</th><th>Siguiente</th></tr></thead><tbody><tr><td>S</td><td>{a,b,c}</td><td>{$}</td></tr><tr><td>A</td><td>{a,Œµ}</td><td></td></tr><tr><td>B</td><td>{b,Œµ}</td><td></td></tr><tr><td>C</td><td>{c}</td><td></td></tr><tr><td>D</td><td>{d,Œµ}</td><td></td></tr><tr><td>E</td><td>{e,Œµ}</td><td></td></tr></tbody></table><p>   Paso 2: Se busca en cada aparicion del no terminal cual es el terminal que lo precede:</p><table><thead><tr><th>no terminal</th><th>Primero</th><th>Siguiente</th></tr></thead><tbody><tr><td>S</td><td>{a,b,c}</td><td>{$}</td></tr><tr><td>A</td><td>{a,Œµ()}</td><td>{b,c}</td></tr><tr><td>B</td><td>{b,Œµ()}</td><td>{c}</td></tr><tr><td>C</td><td>{c}</td><td>{d,e,$}</td></tr><tr><td>D</td><td>{d,Œµ()}</td><td>{e,$}</td></tr><tr><td>E</td><td>{e,Œµ()}</td><td>{$}</td></tr></tbody></table><ol><li><p>Ejemplo 2</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Otro Approach</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>exp ‚Üí exp opsuma term | term </p><p>opsuma ‚Üí + | - </p><p>term ‚Üí term opmult factor | factor </p><p>pomult ‚Üí * </p><p>factor ‚Üí ( exp ) | numero</p></li></ol><p>   Paso 1: Se obtiene el conjunto siguiente de la regla inicial</p><table><thead><tr><th>no terminal</th><th>Primero</th><th>Siguiente</th></tr></thead><tbody><tr><td>exp</td><td>{(,numero}</td><td>{$}</td></tr><tr><td>opsum</td><td>{+,-}</td><td>{}</td></tr><tr><td>term</td><td>{(,numero}</td><td>{}</td></tr><tr><td>factor</td><td>{(, numero}</td><td>{}</td></tr><tr><td>opmult</td><td>{* }</td><td>{}</td></tr></tbody></table><p>   Paso 2: Por cada no terminal se analiza en que producciones aparece y se busca el primer terminal</p><table><thead><tr><th>no terminal</th><th>Primero</th><th>Siguiente</th><th></th></tr></thead><tbody><tr><td>exp</td><td>{(,numero}</td><td>{$,+,-,)}</td><td>{$}‚à™ PRIM(opsum) ‚à™ {)}</td></tr><tr><td>opsum</td><td>{+,-}</td><td>{(,numero}</td><td>{PRIM(term)</td></tr><tr><td>term</td><td>{(,numero}</td><td>{*,$,+,-}</td><td>{*} ‚à™ {PRIM(exp)</td></tr><tr><td>factor</td><td>{*}</td><td>{(, numero)}</td><td>{SIG(term)}</td></tr><tr><td>opmult</td><td>{(,numero}</td><td>{*}</td><td>{PRIM(facto)</td></tr></tbody></table><ol start="6"><li><p>La tabla de analisis sintactico LL(1)</p><p>Al utilizar el m√©todo sint√°ctico descripto, cuando un <strong>no terminal A</strong> esta en la parte superior de la pila de an√°lisis sint√°ctico, debe tomarse una decisi√≥n, basada en el token de entrada actual (la b√∫squeda hacia adelante), que selecciona la regla gramatical que va a utilizar para A cuando se reemplaza en la pila.</p><p>En contraste no es necesario tomar una decisi√≥n cuando el token esta en la parte superior de la pila, puesto que es el mismo que el token de entrada actual, y se presenta una coincidencia, o no lo es y se presenta un error.</p><p>Se pueden expresar las selecciones posibles construyendo una <strong>tabla de an√°lisis sint√°ctico LL(1)</strong> :</p><ul><li><p>Una tabla de esta naturaleza es esencialmente un arreglo bidimensional indexado por no terminales y terminales que contienen opciones de producci√≥n a emplear en el paso apropiado del an√°lisis sint√°ctico (incluyendo $ para representar el final de la entrada).</p></li><li><p>Se Llama a esta tabla M[N,T]. Se supone que la tabla M[N,T] inicia con todas sus entradas vac√≠as. Cualquier entrada que permanezca vac√≠a despu√©s de la construcci√≥n <strong>representa errores potenciales</strong> que se pueden presentar durante el an√°lisis sint√°ctico. Se agrega selecciones u opciones de producci√≥n de acuerdo con las reglas siguientes:</p><ol><li><p>Si A-&gt;Œ± es una opci√≥n de producci√≥n, y existe una derivaci√≥n Œ± =&gt;aŒ≤, donde a es un token, entonces se agrega A-&gt;Œ± a la entrada en la tabla M[A,a].</p></li><li><p>Si A-&gt;Œ± es una opci√≥n de producci√≥n, y existen derivaciones Œ±=&gt;*Œµ, y S $=&gt;*Œ≤Aa Œ≥, donde S es el s√≠mbolo inicial y a es un token (o $), entonces se agrega A-&gt;Œ± a la entrada de la tabla M[A,a].</p></li></ol></li><li><p>La idea de la primera regla es, dado un token <em>a</em> en la entrada, se desea seleccionar la regla S-&gt;Œ± si Œ± puede producir una a para comparar.</p></li><li><p>La idea de la segunda regla, es que si A deriva la cadena vacia Œµ , y si a es un tolken que puede venir legalmente despu√©s de A en una derivaci√≥n, entonces se desea seleccionar A-&gt; Œ± para Hacer que A desaparezca.</p></li></ul><p>Nota: La tabla es una tabla dimensional , en la cual las columnas son los terminales, las filas son los no terminales. Y se llenan siempre PRI(dela parte derecha de la producci√≥n) a menos que A produzca un Œµ por ende se usa el siguiente.</p></li><li><p>Algoritmo de An√°lisis Sint√°ctico LL(1) basado en Tabla</p></li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   while () </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (tope_pila == terminal &amp;&amp; siguite_token ==a)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       //concuerda</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       pila_extraer();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       avanzar_entrada();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }else if ( tope_pila == no_terminal_A &amp;&amp; siguiente_token==a &amp;&amp; M[A,a]== A-&gt;X1X2X3..Xn )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //generar</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      pila_extraer();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      for(i=n; i&gt;=1 ; n--) pila_insertar(xi); </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }else error();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (tope_pila ==$ &amp;&amp; siguiente_token==$) aceptar();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   else error;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="ejemplo-integrado"></a>Ejemplo integrado:<a class="hash-link" href="#ejemplo-integrado" title="Direct link to heading">#</a></h3><p>Sea la gram√°tica:</p><p>  E ‚Üí (L) | id </p><p>  L ‚Üí  L;E | int E</p><p>Para construir un analizador sint√°ctico LL(1) hay que seguir los 5 pasos</p><ul><li><p>Eliminar recursi√≥n a izquierda:</p><p>‚Äã		L‚Üí L;E | int E 		hay recursi√≥n interna, se elimina de la siguiente forma:</p><hr><p>‚Äã        L‚Üí  <em>int</em> E L&#x27; | <em>int</em> E </p><p>‚Äã		L&#x27;‚Üí  <em>;_EL&#x27; | </em>;_E</p></li><li><p>Factorizar a Izquierda</p><p>  L‚Üí  int E L&#x27; | int E </p><p>  L&#x27;‚Üí  ;EL&#x27; | ;E</p><hr><p>  Factorizar la producci√≥n  L‚Üí  int E L&#x27; | int E  </p><p>   L‚Üí  int E W </p><p>   W‚Üí L&#x27; | Œµ</p><hr><p>  Factorizar la producci√≥n L&#x27;‚Üí  ;EL&#x27; | ;E            					</p><p>  L&#x27;‚Üí  ;E V </p><p>  V ‚Üí L&#x27; | Œµ</p><hr><p>  Al final nos queda</p><p>  E ‚Üí  (L) | id </p><p>  L‚Üí  int E W </p><p>  W‚Üí  L&#x27; | Œµ </p><p>  L&#x27;‚Üí  ; E W</p></li><li><p>PRIMEROS y SIGUIENTES</p></li></ul><p> Primeros</p><table><thead><tr><th>NT</th><th>PRIMERO</th><th>SIGUIENTE</th></tr></thead><tbody><tr><td>E</td><td>{(,id}</td><td></td></tr><tr><td>L</td><td>{int}</td><td></td></tr><tr><td>L&#x27;</td><td>{;}</td><td></td></tr><tr><td>W</td><td>{;, epsilon}</td><td></td></tr></tbody></table><p>Siguientes</p><table><thead><tr><th>NT</th><th>PRIMERO</th><th>SIGUIENTE</th><th></th></tr></thead><tbody><tr><td>E</td><td>{( , id}</td><td>{$, ; , ) }</td><td>{$}‚à™{PRIM(W)}‚à™{SIG(L}</td></tr><tr><td>L</td><td>{int}</td><td>{)}</td><td>SIG(L)={)}</td></tr><tr><td>L&#x27;</td><td>{;}</td><td>{)}</td><td>SIG(L&#x27;)=SIG(W)</td></tr><tr><td>W</td><td>{;}</td><td>{)}</td><td>SIG(W)= SIG(L)</td></tr></tbody></table><ul><li><p>Armar la tabla de Parsing</p><table><thead><tr><th></th><th>(</th><th>)</th><th>id</th><th>;</th><th>int</th><th>$</th></tr></thead><tbody><tr><td>E</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>W</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L&#x27;</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>  Como se arma, recordar que en se toma la producci√≥n , se busca el PRIM(produc) ah√≠ se escribe la regla</p><p>  Se toma la primera regla E‚Üí (L) | id</p><table><thead><tr><th></th><th>(</th><th>)</th><th>id</th><th>;</th><th>int</th><th>$</th></tr></thead><tbody><tr><td>E</td><td>E‚Üí (L)</td><td></td><td>E‚Üí id</td><td></td><td></td><td></td></tr><tr><td>L</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>W</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L&#x27;</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>  Se toma la pr√≥xima regla L ‚Üí  int EW</p><table><thead><tr><th></th><th>(</th><th>)</th><th>id</th><th>;</th><th>int</th><th>$</th></tr></thead><tbody><tr><td>E</td><td>E‚Üí (L)</td><td></td><td>E‚Üí id</td><td></td><td></td><td></td></tr><tr><td>L</td><td></td><td></td><td></td><td></td><td>L‚Üí int E W</td><td></td></tr><tr><td>W</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L&#x27;</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>  As√≠ sucesivamente</p><table><thead><tr><th></th><th>(</th><th>)</th><th>id</th><th>;</th><th>int</th><th>$</th></tr></thead><tbody><tr><td>E</td><td>E‚Üí (L)</td><td></td><td>E‚Üí id</td><td></td><td></td><td></td></tr><tr><td>L</td><td></td><td>syntax  error</td><td></td><td></td><td>L‚Üí int E W</td><td></td></tr><tr><td>W</td><td></td><td>w‚Üí Œµ</td><td></td><td>W‚Üí L&#x27;</td><td></td><td></td></tr><tr><td>L&#x27;</td><td></td><td></td><td></td><td>L&#x27;‚Üí ; E W</td><td></td><td></td></tr></tbody></table></li></ul><table><thead><tr><th>(int id ; id )$</th><th>$</th><th></th><th></th></tr></thead><tbody><tr><td>(</td><td>$)L(</td><td>consumo</td><td></td></tr><tr><td>(int</td><td>$)W E int</td><td>consumo</td><td></td></tr><tr><td>(int id</td><td>$)W id</td><td>consumo</td><td></td></tr><tr><td>(int id ;</td><td>$)L&#x27;</td><td></td><td>reemplazo</td></tr><tr><td>(int id ;</td><td>$)WE;</td><td>consumo</td><td></td></tr><tr><td>(int id ; id</td><td>$)Wid</td><td>consumo</td><td></td></tr><tr><td>(int id ; id )</td><td>$)W</td><td></td><td>reemplazo</td></tr><tr><td>(int id ; id )</td><td>$)</td><td>consumo</td><td></td></tr><tr><td>(int id ; id )$</td><td>$            acepto</td><td></td><td></td></tr></tbody></table></div><footer class="docusaurus-mt-lg"><div class="row"><div class="col"><a href="https://github.com/compiladores/compiladores.github.io/edit/master/docs/docs/teoricas/04-analisis-sintactico/02-LL1.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/teoricas/analisis-sintactico/intro"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">¬´ Parsing</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/teoricas/analisis-sintactico/analizadores-sintacticos-ascendentes"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Analizadores Sint√°cticos LR ¬ª</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#el-algoritmo" class="table-of-contents__link">El Algoritmo</a></li><li><a href="#eliminaci√≥n-por-recursi√≥n-por-la-izquierda-y-factorizaci√≥n-por-la-izquierda" class="table-of-contents__link">Eliminaci√≥n por recursi√≥n por la izquierda y factorizaci√≥n por la izquierda</a></li><li><a href="#factorizaci√≥n" class="table-of-contents__link">Factorizaci√≥n</a></li><li><a href="#primero-y-siguiente" class="table-of-contents__link">PRIMERO y SIGUIENTE</a></li><li><a href="#primero-o-first" class="table-of-contents__link">Primero o First</a></li><li><a href="#ejemplo-integrado" class="table-of-contents__link">Ejemplo integrado:</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Material</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/labs/intro">Laboratorios</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Hecho para Ud.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.d9c9bf77.js"></script>
<script src="/assets/js/main.8c8b089d.js"></script>
</body>
</html>
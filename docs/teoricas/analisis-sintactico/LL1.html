<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">Analizadores Sintácticos LL(1) | Lenguajes y Compiladores</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jisbruzzi.github.io/docs/teoricas/analisis-sintactico/LL1"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Analizadores Sintácticos LL(1) | Lenguajes y Compiladores"><meta data-react-helmet="true" name="description" content="El análisis sintáctico LL(1) utiliza una pila explicita en vez de llamadas recursivas para efectuar el análisis sintáctico. Una gramática LL(1) no tiene recursividad por la izquierda y no es ambigua."><meta data-react-helmet="true" property="og:description" content="El análisis sintáctico LL(1) utiliza una pila explicita en vez de llamadas recursivas para efectuar el análisis sintáctico. Una gramática LL(1) no tiene recursividad por la izquierda y no es ambigua."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://jisbruzzi.github.io/docs/teoricas/analisis-sintactico/LL1"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/teoricas/analisis-sintactico/LL1" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/teoricas/analisis-sintactico/LL1" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.a91fdf40.css">
<link rel="preload" href="/assets/js/runtime~main.d9c9bf77.js" as="script">
<link rel="preload" href="/assets/js/main.8c8b089d.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Lenguajes y Compiladores</b></a><a class="navbar__item navbar__link" href="/docs/labs/intro">Laboratorios</a><a class="navbar__item navbar__link" href="/docs/practicas/intro">Prácticas</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/teoricas/intro">Teóricas</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/docs/labs/intro_teorica">este cuatri</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link navbar__link--active" href="/docs/teoricas/analisis-sintactico/LL1">este cuatri</a></li><li><a class="dropdown__link" href="/docs/2021_2/teoricas/analisis-sintactico/LL1">2021_2</a></li></ul></div><a href="https://github.com/compiladores" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/teoricas/intro">Compiladores</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/teoricas/proc-lenguaje">Procesadores de Lenguaje</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-lexico</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">analisis-sintactico</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/teoricas/analisis-sintactico/intro">Parsing</a></li><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/teoricas/analisis-sintactico/LL1">Analizadores Sintácticos LL(1)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/teoricas/analisis-sintactico/analizadores-sintacticos-ascendentes">Analizadores Sintácticos LR</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/teoricas/analisis-sintactico/analisis-sintactico-lr">Analizadores Sintácticos</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/teoricas/analisis-sintactico/generadores">Generadores de Analizadores Sintácticos</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-semantico</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/teoricas/bibliografia">Bibliografia</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">generacion-ir</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/teoricas/bibliografia">Bibliografia</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><span class="badge badge--secondary">Version: este cuatri</span><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1>Analizadores Sintácticos LL(1)</h1></header><p>El análisis sintáctico LL(1) utiliza una pila explicita en vez de llamadas recursivas para efectuar el análisis sintáctico. Una gramática LL(1) <strong>no tiene recursividad por la izquierda y no es ambigua</strong>.</p><p>Entonces antes de armar el parser se debe verificar que la gramática sea LL(1) o se transforma la gramática con la que se está trabajando en LL(1) mediante la aplicación de las siguientes técnicas:</p><ul><li><p>Eliminación de la recursividad por Izquierda</p></li><li><p>Eliminación de ambigüedad</p></li><li><p>Un analizador sintáctico descendente comienza a insertar el símbolo inicial sobre la pila. <strong>Acepta</strong> una cadena de entrada, si, después de una serie de acciones, la pila y la entrada se quedan vacías.</p></li><li><p>Un analizador sintáctico descendente realiza su análisis al reemplazar un no terminal en la parte superior de la pila por una de las elecciones en la regla gramatical (en BNF) para ese no terminal. Realiza esto con miras a producir el token de entrada actual en la parte superior de la pila de análisis sintáctico, de donde ha reconocido el token de entrada y puede descartarlo tanto de la pila como de la entrada. Estas dos acciones,</p><ol><li><p><strong>Reemplazar</strong> un no terminal A en la parte superior de la pila mediante una cadena α utilizando la selección de la regla gramatical A-&gt;alpha, y</p></li><li><p>Hacer <strong>concordar</strong> un token en la parte superior de la pila con el siguiente token de entrada.</p></li></ol></li></ul><p>Son las dos acciones básicas de un analizador sintáctico descendente.</p><ul><li>La primera acción se llama <strong>generar</strong>.</li></ul><ul><li>La segunda acción hace <strong>concordar</strong> a un token en la parte superior de la pila con el siguiente token en la entrada (y los desecha a ambos sacándolos de la pila y avanzando a la entrada); indicamos esta acción indicando la palabra <strong>match</strong>.</li></ul><p>Es importante advertir que en la acción <strong>generar</strong>, la cadena de reemplazo α se debe insertar en reversa en la pila (ya que eso asegurara que la cadena α arribara a la parte superior de la pila en el orden de izquierda a derecha).</p><ol><li><p>Ejemplo</p><p>Sea la gramática:</p></li></ol><p>S-&gt;(S)S | ε</p><table><thead><tr><th></th><th>pila</th><th>entrada</th><th>acción</th><th></th></tr></thead><tbody><tr><td>1</td><td>$S</td><td>()$</td><td>S-&gt;(S)S</td><td></td></tr><tr><td>2</td><td>$S)S(</td><td>()$</td><td>match</td><td></td></tr><tr><td>3</td><td>$S)S</td><td>)$</td><td>S-&gt;ε</td><td></td></tr><tr><td>4</td><td>$S)</td><td>)$</td><td>match</td><td></td></tr><tr><td>5</td><td>$S</td><td>$</td><td>S-&gt;ε</td><td></td></tr><tr><td>6</td><td>$</td><td>$</td><td>aceptar</td><td></td></tr></tbody></table><p>Lo que se realizó, es justamente la derivación:</p><p>   S -&gt; ( S ) S -&gt; ( ) S [S -&gt; ε] -&gt; ( ) [S -&gt; ε]</p><p>Tabla de parsing:</p><table><thead><tr><th>M[N,T]</th><th>(</th><th>)</th><th>S</th></tr></thead><tbody><tr><td>S</td><td>S-&gt;(S)S</td><td>S-&gt;ε</td><td>S-&gt;ε</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="el-algoritmo"></a>El Algoritmo<a class="hash-link" href="#el-algoritmo" title="Direct link to heading">#</a></h3><p>Para armar un parser LL(1) es necesario cumplir con un conjuntos de pasos. Dado una gramática libre de contexto a la que se quiere construir un analizador sintáctico LL(1), es necesario:</p><ul><li>Eliminar la recursión por izquierda de la gramática</li><li>Factorizar por la Izquierda la gramática</li><li>Construir el conjunto de PRIMEROS</li><li>Construir el Conjunto de SIGUIENTES</li><li>Construir la tabla de Parsing</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="eliminación-por-recursión-por-la-izquierda-y-factorización-por-la-izquierda"></a>Eliminación por recursión por la izquierda y factorización por la izquierda<a class="hash-link" href="#eliminación-por-recursión-por-la-izquierda-y-factorización-por-la-izquierda" title="Direct link to heading">#</a></h3><p>   ¿Que es la recursión por izquierda en una gramática?</p><p>   A → A α | β</p><p>   Donde α y β son cadenas de terminales y no terminales , y β no comienza con A. Entonces A → β es el caso base, mientras que A → A α es el caso recursivo.</p><ul><li>La eliminación de recursión a la izquierda no cambia el lenguaje que se está reconocienndo.</li></ul><ol><li><p>Eliminación de recursión por la Izquierda simple</p><p>Para eliminar la recursión por izquierda se reescriben las reglas gramaticales divididas en dos</p><p>Sea la gramática:</p><p>​               A → Aα | β</p><p>una que primero genera β y la otra que genere las repeticiones de α utilizando recursividad por derecha :</p><p>​               A → β A&#x27; </p><p>​               A&#x27; → α A&#x27; | ε</p><p>Otro ejemplo :</p></li></ol><p>Sea la gramática :</p><p>​                    exp → exp opsuma term | term</p><p>Se genera según la regla la siguiente gramática:</p><p>​                    exp → term exp&#x27; </p><p>​                     exp&#x27; → opsuma term exp&#x27; | ε</p><p>​      </p><ol start="2"><li>Eliminación  Recursión por la Izquierda Inmediata General</li></ol><p>Sean las siguientes producciones:</p><p>​                              A → A α<sub>1</sub>| A α<sub>2</sub> |… | A α<sub>n</sub> | β<sub>1</sub> | β<sub>2</sub> | … | β<sub>m</sub></p><p>Donde ninguna de la β comienza con A. En este caso la solución es semejante al caso simple:</p><p>​                               A → β<sub>1</sub> A&#x27;| β<sub>2</sub>A&#x27; | … | β<sub>m</sub>A&#x27; </p><p>​                               A&#x27; → α<sub>1</sub>A&#x27;| α<sub>2</sub>A&#x27; |… | α<sub>n</sub> A&#x27; | ε</p><p>Ejemplo:</p><p>​                             exp → exp + term | exp - term | term</p><p>Aplicando la regla general inmediata:</p><p>​      </p><p>​                             exp → term exp&#x27; </p><p>​                             exp&#x27; → + term exp&#x27; | - term exp&#x27; | ε</p><p>​      </p><ol start="3"><li>Eliminación de Recursión por Izquierda General:</li></ol><p>A continuación se propone un algoritmo que elimina de forma sistemática la recursividad por la izquierda de una gramática. Esto se garantiza si la gramática no tiene ciclos ( derivaciones de A → +A) o producciones ε. Si los hubiera estos pueden eliminarse de la gramatica.</p><ul><li>El algoritmo:</li><li>ENTRADA: La gramática G sin ciclos ni producciones ε().</li><li>SALIDA: Una gramática equivalente sin recursividad por la izquierda.</li><li>MÉTODO:
</li></ul><p>ordenar los nodos no terminales de cierta forma A<sub>1</sub>, … A<sub>n</sub> </p><p>for ( cada i de 1 a n){
for ( cada j de 1 a i-1) {
sustituir cada producción de la forma A<sub>i</sub> → A<sub>j</sub>γ por las producciones A<sub>i</sub> -&gt; δ<sub>1</sub> γ() | …..| δ<sub>k</sub>γ en donde A<sub>j</sub> → delta<sub>1</sub> | δ<sub>2</sub> | ….. | δ<sub>k</sub> sean todas producciones A<sub>j</sub> actuales
}
Eliminar la recursividad inmediata por la izquierda entre la producciones A<sub>i</sub>
}</p><ol><li>Ejemplo</li></ol><p>Intentar aplicar el algoritmo general: </p><p>S → Aa | b
A → Ac | Sd | ε</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="factorización"></a>Factorización<a class="hash-link" href="#factorización" title="Direct link to heading">#</a></h3><p>   La factorización por izquierda se requiere cuando dos o más opciones de reglas gramaticales comparten una cadena de prefijo común:</p><p>   A → αβ | αγ</p><p>   Un analizador sintáctico LL(1) no puede distinguir entre las opciones de producción en una sustitución de esta clase. Para solucionar esto es factorizar la α por la izquierda y volver a escribir la regla como dos reglas:</p><p>   A → α A&#x27; </p><p>   A&#x27; → β | γ</p><p>   Otros ejemplos:</p><p>   secuencia-sent → sent ; secuencia-sent | sent </p><p>   sent → s</p><p>   Al aplicar la factorización se obtiene dos reglas:</p><p>   secuencia-sent → sent secuencia-sent&#x27; </p><p>   secuencia-sent&#x27; →  ; | ε</p><p>   La gramática resultante :</p><p>   secuencia-sent → sent secuencia-sent&#x27; </p><p>   secuencia-sent&#x27; →  ; | ε </p><p>   sent → s</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="primero-y-siguiente"></a>PRIMERO y SIGUIENTE<a class="hash-link" href="#primero-y-siguiente" title="Direct link to heading">#</a></h3><p>(Aho:p221, lou:p168, Coo:p )</p><p>Si una gramática posee un conjunto de producciones en la cual no es posible determinar a ciencia cierta cual es la producción seleccionada por la cual se está derivando entonces, en la construcción de analizadores sintácticos descendientes ( y también ascendentes) se utilizan dos funciones auxiliares asociadas con la gramática G, PRIMERO() y SIGUIENTE():</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="primero-o-first"></a>Primero o First<a class="hash-link" href="#primero-o-first" title="Direct link to heading">#</a></h3><p>PRIMERO(α), donde α es cualquier cadena de símbolos gramaticales, como el conjunto de terminales que empiezan las cadenas derivadas a partir de α. Cómo se calcula el conjunto PRIMERO o First:</p><p>Si X es un símbolo de la gramática ( un terminal o un no terminal) o ε, entonces el conjunto <strong>Primero(X)</strong>, compuesto de terminales, y posiblemente de ε, se define de la siguiente manera:</p><ol><li>Si X es un terminal o ε, entonces Primero(X)={X}.</li><li>Si X es no terminal, entonces para cada selección de producción X -&gt; X<sub>1</sub> X<sub>2</sub> … X<sub>n</sub>, Primero(X) contiene Primero{X<sub>1</sub>} - ε.</li></ol><ul><li>Si también para cualquier i&lt;n, todos los conjuntos Primeros(X<sub>1</sub>) -&gt; Primero(x<sub>i</sub>, contienen ε, entonces Primero(X)=Primero(X<sub>1</sub>) -ε.</li><li>Si todos los conjuntos Primer(X<sub>i</sub>) contiene ε, entonces Primero(X) contiene ε.</li></ul><ol start="3"><li><p>El conjunto de PRIMEROS son aquellos caracteres que van a identificar en que producción estoy de las varias producciones de una gramática.</p><p>Algunos ejemplos de la aplicación de estas reglas :</p><p>A → tB     entonces PRIMERO(A)={t} </p><p>A → Bβ    entonces también PRIMERO(A)=PRIMERO(B)</p></li></ol><ol><li><p>Ejemplo</p><p>A → aC </p><p>B → ε | m </p><p>C → ε | s | y</p></li></ol><p>​     </p><p>Otra opción de ver la gramatica:</p><p>   A → aC </p><p>   B → ε </p><p>   B → m </p><p>   C → ε </p><p>   C→ s</p><p>   Nota: siempre conviene primero obtener los consjuntos primeros de las derivaciones con no terminales:</p><p>   Paso 1: Obtengo las producciones que derivan en no terminales</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>A</td><td>{a}</td></tr><tr><td>B</td><td>{m, ε }</td></tr><tr><td>C</td><td>{s, ε}</td></tr></tbody></table><p>   Paso 2: De las producciones que derivan en no terminales elijo el primer no terminal y voy a su producción, hasta alcanzar a un terminal</p><ul><li>En este caso no hay, es el caso más fácil</li></ul><ol><li><p>Ejemplo</p><p>S → ABCDE </p><p>A → a | ε</p><p>B → b | ε</p><p>C → c</p><p>D → d | ε </p><p>E → e | ε</p><p>Nota: siempre conviene primero obtener los conjuntos primeros de las derivaciones con no terminales:</p><p>Paso 1: Obtengo las producciones que derivan en no terminales</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>S</td><td>{}</td></tr><tr><td>A</td><td>{a,ε}</td></tr><tr><td>B</td><td>{b,ε}</td></tr><tr><td>C</td><td>{c}</td></tr><tr><td>D</td><td>{d,ε}</td></tr><tr><td>E</td><td>{e,ε}</td></tr></tbody></table><p>Paso 2: De las producciones que derivan en no terminales elijo el primer no terminal y voy a su producción, hasta alcanzar a un terminal</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>S</td><td>{a,b,c}</td></tr><tr><td>A</td><td>{a,ε}</td></tr><tr><td>B</td><td>{b,ε}</td></tr><tr><td>C</td><td>{c}</td></tr><tr><td>D</td><td>{d,ε}</td></tr><tr><td>E</td><td>{e,ε}</td></tr></tbody></table></li><li><p>Ejemplo</p><p>   exp -&gt; exp opsuma term | term </p><p>   opsuma -&gt; + | - </p><p>   term -&gt; term opmult term | factor </p><p>   opmult -&gt; * </p><p>   factor -&gt; ( exp ) | numero</p><p>   es conveniente separar las producciones que queden de a una:</p></li></ol><table><thead><tr><th>n</th><th>producción</th></tr></thead><tbody><tr><td>1</td><td>exp          -&gt; exp opsuma term</td></tr><tr><td>2</td><td>exp          -&gt; term</td></tr><tr><td>3</td><td>opsuma       -&gt; +</td></tr><tr><td>4</td><td>opsuma       -&gt; -</td></tr><tr><td>5</td><td>term         -&gt; term opmult term</td></tr><tr><td>6</td><td>term         -&gt; factor</td></tr><tr><td>7</td><td>opmult       -&gt; *</td></tr><tr><td>8</td><td>factor       -&gt; ( exp )</td></tr><tr><td>9</td><td>factor       -&gt; numero</td></tr></tbody></table><p>Nota: siempre conviene primero obtener los conjuntos primeros de las derivaciones con no terminales:</p><p>Paso 1: Obtengo las producciones que derivan en no terminales</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>exp</td><td>{}</td></tr><tr><td>opsum</td><td>{+,-}</td></tr><tr><td>term</td><td>{}</td></tr><tr><td>opmult</td><td>{*}</td></tr><tr><td>factor</td><td>{}</td></tr></tbody></table><p>Paso 2: De las producciones que derivan en no terminales elijo el primer no terminal y voy a su producción, hasta alcanzar a un terminal</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>exp</td><td>{(,numero}</td></tr><tr><td>opsum</td><td>{+,-}</td></tr><tr><td>term</td><td>{(,numero}</td></tr><tr><td>opmult</td><td>{*}</td></tr><tr><td>factor</td><td>{(,numero}</td></tr></tbody></table><ol><li><p>Ejemplo</p><p>E → T E&#x27; </p><p>E&#x27; → + T E&#x27; | ε </p><p>T → F T&#x27; </p><p>T&#x27; → * F T&#x27; | ε </p><p>F → ( E ) | id</p></li></ol><p>   Nota: siempre conviene primero obtener los conjuntos primeros de las derivaciones con terminales:</p><p>   Paso 1: Obtengo las producciones que derivan en no terminales</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>E</td><td></td></tr><tr><td>E&#x27;</td><td>{+, ε</td></tr><tr><td>T</td><td></td></tr><tr><td>T&#x27;</td><td>{\*, ε}</td></tr><tr><td>F</td><td>{ (, id}</td></tr></tbody></table><p>   Paso 2: De las produccciones que derivan en no terminales elijo el primer no terminal y voy a su producción, hasta alcanzar a un terminal</p><table><thead><tr><th>no terminal</th><th>Primero</th></tr></thead><tbody><tr><td>E</td><td>{ (, id}</td></tr><tr><td>E&#x27;</td><td>{+, ε}</td></tr><tr><td>T</td><td>{ (, id}</td></tr><tr><td>T&#x27;</td><td>{\*, ε}</td></tr><tr><td>F</td><td>{ (, id}</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="siguiente-o-follow"></a>SIGUIENTE o Follow<a class="hash-link" href="#siguiente-o-follow" title="Direct link to heading">#</a></h4><p>Se define <strong>SIGUIENTE(A), para el no terminal A, como el conjunto de terminales <span class="underline">b</span> que pueden aparecer de inmediato a la derecha de A en cierta forma de frase</strong>. Cómo se calcula:</p><p>Dado un nodo <strong>no terminal</strong>, el conjunto <strong>Siguiente(A)</strong>, compuesto de <strong>terminales</strong>, y posiblemente de $ (fin de pila), se define de la siguiente manera:</p><ol><li><p>Si A es el símbolo inicial, entonces $ está en Siguiente(A).</p></li><li><p>Si hay una producción B → α A γ, entonces Primero(γ) - {ε} está en Siguiente(A).</p></li><li><p>Si hay una producción B → α A γ tal que ε está en Primero(γ), entonces Siguiente(A) contiene Siguiente(B).</p></li><li><p>En otras palabras, el siguiente me indica que terminé con una producción, es decir cual es el terminal que se encuentra al finalizar esa producción</p><p>Algunos ejemplos:</p><p>B → AC                          entonces SIG(A)=PRIMERO(C)</p><p>S → α                             entonces SIG(S)={$}</p><p>B → Ac                           entonces el SIG(A)={c}</p><p>B → cA                           entonces el SIG(A)= SIG(B) ya que A está al final de lo      </p><p>​                                        que se reemplaza por B</p><p>B → ε                              entonces SIG(P)={d} </p><p>C → PBd</p></li></ol><ol><li><p>Ejemplo 1</p><p>S → ABCDE </p><p>A → a | ε</p><p>B → b | ε</p><p>C → c </p><p>D → d | ε </p><p>E → e | ε</p></li></ol><p>   Nota: Se buscan los caracteres que indiquen que una producción ha terminado.</p><p>   Paso 1: El siguiente del símbolo inicial es $</p><table><thead><tr><th>no terminal</th><th>Primero</th><th>Siguiente</th></tr></thead><tbody><tr><td>S</td><td>{a,b,c}</td><td>{$}</td></tr><tr><td>A</td><td>{a,ε}</td><td></td></tr><tr><td>B</td><td>{b,ε}</td><td></td></tr><tr><td>C</td><td>{c}</td><td></td></tr><tr><td>D</td><td>{d,ε}</td><td></td></tr><tr><td>E</td><td>{e,ε}</td><td></td></tr></tbody></table><p>   Paso 2: Se busca en cada aparicion del no terminal cual es el terminal que lo precede:</p><table><thead><tr><th>no terminal</th><th>Primero</th><th>Siguiente</th></tr></thead><tbody><tr><td>S</td><td>{a,b,c}</td><td>{$}</td></tr><tr><td>A</td><td>{a,ε()}</td><td>{b,c}</td></tr><tr><td>B</td><td>{b,ε()}</td><td>{c}</td></tr><tr><td>C</td><td>{c}</td><td>{d,e,$}</td></tr><tr><td>D</td><td>{d,ε()}</td><td>{e,$}</td></tr><tr><td>E</td><td>{e,ε()}</td><td>{$}</td></tr></tbody></table><ol><li><p>Ejemplo 2</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Otro Approach</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>exp → exp opsuma term | term </p><p>opsuma → + | - </p><p>term → term opmult factor | factor </p><p>pomult → * </p><p>factor → ( exp ) | numero</p></li></ol><p>   Paso 1: Se obtiene el conjunto siguiente de la regla inicial</p><table><thead><tr><th>no terminal</th><th>Primero</th><th>Siguiente</th></tr></thead><tbody><tr><td>exp</td><td>{(,numero}</td><td>{$}</td></tr><tr><td>opsum</td><td>{+,-}</td><td>{}</td></tr><tr><td>term</td><td>{(,numero}</td><td>{}</td></tr><tr><td>factor</td><td>{(, numero}</td><td>{}</td></tr><tr><td>opmult</td><td>{* }</td><td>{}</td></tr></tbody></table><p>   Paso 2: Por cada no terminal se analiza en que producciones aparece y se busca el primer terminal</p><table><thead><tr><th>no terminal</th><th>Primero</th><th>Siguiente</th><th></th></tr></thead><tbody><tr><td>exp</td><td>{(,numero}</td><td>{$,+,-,)}</td><td>{$}∪ PRIM(opsum) ∪ {)}</td></tr><tr><td>opsum</td><td>{+,-}</td><td>{(,numero}</td><td>{PRIM(term)</td></tr><tr><td>term</td><td>{(,numero}</td><td>{*,$,+,-}</td><td>{*} ∪ {PRIM(exp)</td></tr><tr><td>factor</td><td>{*}</td><td>{(, numero)}</td><td>{SIG(term)}</td></tr><tr><td>opmult</td><td>{(,numero}</td><td>{*}</td><td>{PRIM(facto)</td></tr></tbody></table><ol start="6"><li><p>La tabla de analisis sintactico LL(1)</p><p>Al utilizar el método sintáctico descripto, cuando un <strong>no terminal A</strong> esta en la parte superior de la pila de análisis sintáctico, debe tomarse una decisión, basada en el token de entrada actual (la búsqueda hacia adelante), que selecciona la regla gramatical que va a utilizar para A cuando se reemplaza en la pila.</p><p>En contraste no es necesario tomar una decisión cuando el token esta en la parte superior de la pila, puesto que es el mismo que el token de entrada actual, y se presenta una coincidencia, o no lo es y se presenta un error.</p><p>Se pueden expresar las selecciones posibles construyendo una <strong>tabla de análisis sintáctico LL(1)</strong> :</p><ul><li><p>Una tabla de esta naturaleza es esencialmente un arreglo bidimensional indexado por no terminales y terminales que contienen opciones de producción a emplear en el paso apropiado del análisis sintáctico (incluyendo $ para representar el final de la entrada).</p></li><li><p>Se Llama a esta tabla M[N,T]. Se supone que la tabla M[N,T] inicia con todas sus entradas vacías. Cualquier entrada que permanezca vacía después de la construcción <strong>representa errores potenciales</strong> que se pueden presentar durante el análisis sintáctico. Se agrega selecciones u opciones de producción de acuerdo con las reglas siguientes:</p><ol><li><p>Si A-&gt;α es una opción de producción, y existe una derivación α =&gt;aβ, donde a es un token, entonces se agrega A-&gt;α a la entrada en la tabla M[A,a].</p></li><li><p>Si A-&gt;α es una opción de producción, y existen derivaciones α=&gt;*ε, y S $=&gt;*βAa γ, donde S es el símbolo inicial y a es un token (o $), entonces se agrega A-&gt;α a la entrada de la tabla M[A,a].</p></li></ol></li><li><p>La idea de la primera regla es, dado un token <em>a</em> en la entrada, se desea seleccionar la regla S-&gt;α si α puede producir una a para comparar.</p></li><li><p>La idea de la segunda regla, es que si A deriva la cadena vacia ε , y si a es un tolken que puede venir legalmente después de A en una derivación, entonces se desea seleccionar A-&gt; α para Hacer que A desaparezca.</p></li></ul><p>Nota: La tabla es una tabla dimensional , en la cual las columnas son los terminales, las filas son los no terminales. Y se llenan siempre PRI(dela parte derecha de la producción) a menos que A produzca un ε por ende se usa el siguiente.</p></li><li><p>Algoritmo de Análisis Sintáctico LL(1) basado en Tabla</p></li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   while () </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (tope_pila == terminal &amp;&amp; siguite_token ==a)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       //concuerda</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       pila_extraer();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       avanzar_entrada();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }else if ( tope_pila == no_terminal_A &amp;&amp; siguiente_token==a &amp;&amp; M[A,a]== A-&gt;X1X2X3..Xn )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      //generar</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      pila_extraer();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      for(i=n; i&gt;=1 ; n--) pila_insertar(xi); </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }else error();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   if (tope_pila ==$ &amp;&amp; siguiente_token==$) aceptar();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   else error;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="ejemplo-integrado"></a>Ejemplo integrado:<a class="hash-link" href="#ejemplo-integrado" title="Direct link to heading">#</a></h3><p>Sea la gramática:</p><p>  E → (L) | id </p><p>  L →  L;E | int E</p><p>Para construir un analizador sintáctico LL(1) hay que seguir los 5 pasos</p><ul><li><p>Eliminar recursión a izquierda:</p><p>​		L→ L;E | int E 		hay recursión interna, se elimina de la siguiente forma:</p><hr><p>​        L→  <em>int</em> E L&#x27; | <em>int</em> E </p><p>​		L&#x27;→  <em>;_EL&#x27; | </em>;_E</p></li><li><p>Factorizar a Izquierda</p><p>  L→  int E L&#x27; | int E </p><p>  L&#x27;→  ;EL&#x27; | ;E</p><hr><p>  Factorizar la producción  L→  int E L&#x27; | int E  </p><p>   L→  int E W </p><p>   W→ L&#x27; | ε</p><hr><p>  Factorizar la producción L&#x27;→  ;EL&#x27; | ;E            					</p><p>  L&#x27;→  ;E V </p><p>  V → L&#x27; | ε</p><hr><p>  Al final nos queda</p><p>  E →  (L) | id </p><p>  L→  int E W </p><p>  W→  L&#x27; | ε </p><p>  L&#x27;→  ; E W</p></li><li><p>PRIMEROS y SIGUIENTES</p></li></ul><p> Primeros</p><table><thead><tr><th>NT</th><th>PRIMERO</th><th>SIGUIENTE</th></tr></thead><tbody><tr><td>E</td><td>{(,id}</td><td></td></tr><tr><td>L</td><td>{int}</td><td></td></tr><tr><td>L&#x27;</td><td>{;}</td><td></td></tr><tr><td>W</td><td>{;, epsilon}</td><td></td></tr></tbody></table><p>Siguientes</p><table><thead><tr><th>NT</th><th>PRIMERO</th><th>SIGUIENTE</th><th></th></tr></thead><tbody><tr><td>E</td><td>{( , id}</td><td>{$, ; , ) }</td><td>{$}∪{PRIM(W)}∪{SIG(L}</td></tr><tr><td>L</td><td>{int}</td><td>{)}</td><td>SIG(L)={)}</td></tr><tr><td>L&#x27;</td><td>{;}</td><td>{)}</td><td>SIG(L&#x27;)=SIG(W)</td></tr><tr><td>W</td><td>{;}</td><td>{)}</td><td>SIG(W)= SIG(L)</td></tr></tbody></table><ul><li><p>Armar la tabla de Parsing</p><table><thead><tr><th></th><th>(</th><th>)</th><th>id</th><th>;</th><th>int</th><th>$</th></tr></thead><tbody><tr><td>E</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>W</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L&#x27;</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>  Como se arma, recordar que en se toma la producción , se busca el PRIM(produc) ahí se escribe la regla</p><p>  Se toma la primera regla E→ (L) | id</p><table><thead><tr><th></th><th>(</th><th>)</th><th>id</th><th>;</th><th>int</th><th>$</th></tr></thead><tbody><tr><td>E</td><td>E→ (L)</td><td></td><td>E→ id</td><td></td><td></td><td></td></tr><tr><td>L</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>W</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L&#x27;</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>  Se toma la próxima regla L →  int EW</p><table><thead><tr><th></th><th>(</th><th>)</th><th>id</th><th>;</th><th>int</th><th>$</th></tr></thead><tbody><tr><td>E</td><td>E→ (L)</td><td></td><td>E→ id</td><td></td><td></td><td></td></tr><tr><td>L</td><td></td><td></td><td></td><td></td><td>L→ int E W</td><td></td></tr><tr><td>W</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L&#x27;</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>  Así sucesivamente</p><table><thead><tr><th></th><th>(</th><th>)</th><th>id</th><th>;</th><th>int</th><th>$</th></tr></thead><tbody><tr><td>E</td><td>E→ (L)</td><td></td><td>E→ id</td><td></td><td></td><td></td></tr><tr><td>L</td><td></td><td>syntax  error</td><td></td><td></td><td>L→ int E W</td><td></td></tr><tr><td>W</td><td></td><td>w→ ε</td><td></td><td>W→ L&#x27;</td><td></td><td></td></tr><tr><td>L&#x27;</td><td></td><td></td><td></td><td>L&#x27;→ ; E W</td><td></td><td></td></tr></tbody></table></li></ul><table><thead><tr><th>(int id ; id )$</th><th>$</th><th></th><th></th></tr></thead><tbody><tr><td>(</td><td>$)L(</td><td>consumo</td><td></td></tr><tr><td>(int</td><td>$)W E int</td><td>consumo</td><td></td></tr><tr><td>(int id</td><td>$)W id</td><td>consumo</td><td></td></tr><tr><td>(int id ;</td><td>$)L&#x27;</td><td></td><td>reemplazo</td></tr><tr><td>(int id ;</td><td>$)WE;</td><td>consumo</td><td></td></tr><tr><td>(int id ; id</td><td>$)Wid</td><td>consumo</td><td></td></tr><tr><td>(int id ; id )</td><td>$)W</td><td></td><td>reemplazo</td></tr><tr><td>(int id ; id )</td><td>$)</td><td>consumo</td><td></td></tr><tr><td>(int id ; id )$</td><td>$            acepto</td><td></td><td></td></tr></tbody></table></div><footer class="docusaurus-mt-lg"><div class="row"><div class="col"><a href="https://github.com/compiladores/compiladores.github.io/edit/master/docs/docs/teoricas/04-analisis-sintactico/02-LL1.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/teoricas/analisis-sintactico/intro"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Parsing</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/teoricas/analisis-sintactico/analizadores-sintacticos-ascendentes"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Analizadores Sintácticos LR »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#el-algoritmo" class="table-of-contents__link">El Algoritmo</a></li><li><a href="#eliminación-por-recursión-por-la-izquierda-y-factorización-por-la-izquierda" class="table-of-contents__link">Eliminación por recursión por la izquierda y factorización por la izquierda</a></li><li><a href="#factorización" class="table-of-contents__link">Factorización</a></li><li><a href="#primero-y-siguiente" class="table-of-contents__link">PRIMERO y SIGUIENTE</a></li><li><a href="#primero-o-first" class="table-of-contents__link">Primero o First</a></li><li><a href="#ejemplo-integrado" class="table-of-contents__link">Ejemplo integrado:</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Material</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/labs/intro">Laboratorios</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Hecho para Ud.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.d9c9bf77.js"></script>
<script src="/assets/js/main.8c8b089d.js"></script>
</body>
</html>
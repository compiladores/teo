<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">An√°lisis L√©xico | Lenguajes y Compiladores</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-lexico/intro"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="2021_2"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-2021_2"><meta data-react-helmet="true" property="og:title" content="An√°lisis L√©xico | Lenguajes y Compiladores"><meta data-react-helmet="true" name="description" content="Introducci√≥n  [dragon-3]"><meta data-react-helmet="true" property="og:description" content="Introducci√≥n  [dragon-3]"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-lexico/intro"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-lexico/intro" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-lexico/intro" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.a91fdf40.css">
<link rel="preload" href="/assets/js/runtime~main.7e3c6e03.js" as="script">
<link rel="preload" href="/assets/js/main.4a390fc5.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Lenguajes y Compiladores</b></a><a class="navbar__item navbar__link" href="/docs/2021_2/labs/intro">Laboratorios</a><a class="navbar__item navbar__link" href="/docs/2021_2/practicas/intro">Pr√°cticas</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/2021_2/teoricas/intro">Te√≥ricas</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/docs/2021_2/labs/Trabajo Pr√°ctico">2021_2</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/teoricas/analisis-lexico/intro">este cuatri</a></li><li><a aria-current="page" class="dropdown__link navbar__link--active" href="/docs/2021_2/teoricas/analisis-lexico/intro">2021_2</a></li></ul></div><a href="https://github.com/compiladores" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">üåú</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">üåû</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/2021_2/teoricas/intro">Compiladores</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/2021_2/teoricas/proc-lenguaje">Procesadores de Lenguaje</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">analisis-lexico</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/2021_2/teoricas/analisis-lexico/intro">An√°lisis L√©xico</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/2021_2/teoricas/analisis-lexico/analisis-lexico">Generadores de Analizadores L√©xicos</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-sintactico</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-semantico</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/2021_2/teoricas/bibliografia">Bibliografia</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">generacion-ir</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="alert alert--warning margin-bottom--md" role="alert"><div>This is documentation for Lenguajes y Compiladores <b>2021_2</b>, which is no longer actively maintained.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/docs/teoricas/analisis-lexico/intro">latest version</a></b> (este cuatri).</div></div><div class="docItemContainer_33ec"><article><span class="badge badge--secondary">Version: 2021_2</span><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1>An√°lisis L√©xico</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="introducci√≥n--dragon-3"></a>Introducci√≥n  [dragon-3]<a class="hash-link" href="#introducci√≥n--dragon-3" title="Direct link to heading">#</a></h3><p>Como la primera fase de un compilador la principal tarea del analizador l√©xico es:</p><ul><li><p>leer los caracteres de la entrada del programa fuente,</p></li><li><p>agruparlos en lexemas</p></li><li><p>y producir como salida una secuencia de tokens para cada lexema del programa fuente.</p></li><li><p>Interact√∫a con:</p><ul><li>El analizador sint√°ctico para su an√°lisis</li><li>Tambi√©n con la tabla de s√≠mbolos.</li></ul></li></ul><ol><li><p>An√°lisis L√©xico vs An√°lisis Sint√°ctico</p><p>Existen varias razones por la cual separar al an√°lisis l√©xico del an√°lisis sint√°ctico dentro de un compilador:</p><ol><li><p>La sencillez del dise√±o es la consideraci√≥n m√°s importante -&gt; permite simplificar alguna de las dos tareas.</p></li><li><p>Se mejora la eficiencia del compilador. Escribir el lexer separado permite aplicar t√©cnicas especificas que s√≥lo sirven para esta tarea.</p></li><li><p>Se mejora la portabilidad del compilador -&gt; Las particularidades de los dispositivos de entrada se restringen solo al lexer.</p></li></ol></li><li><p>Definiciones</p><ol><li><p>Token</p><ul><li><p>Un token es un par que consiste en un nombre de token y un valor de atributo opcional</p></li><li><p>El nombre del token es un s√≠mbolo abstracto que representa un tipo de unidad l√©xica; por ejemplo una palabra clave, un identificador. Es una <strong>palabra clasificada</strong>.</p><ul><li>Son los s√≠mbolos de entrada del analizador sint√°ctico.</li></ul></li></ul></li><li><p>Patr√≥n</p><ul><li>Un patr√≥n es una descripci√≥n de la forma que pueden tomar los lexemas de un token. En el caso de una palabra reservada como token, el patr√≥n es s√≥lo la secuencia de caracteres que forman la palabra reservada.</li></ul></li><li><p>Lexema</p><ul><li>Es una secuencia de caracteres en el programa fuente, que coinciden con el patr√≥n para un token y que el analizador l√©xico identifica como una instancia de ese token</li></ul></li></ol></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="expresiones-regulares-introducci√≥n"></a>Expresiones Regulares: Introducci√≥n<a class="hash-link" href="#expresiones-regulares-introducci√≥n" title="Direct link to heading">#</a></h3><p>Las <strong>expresiones regulares son lenguajes para expresar patrones</strong>. Fueron descriptas en 1950 por <strong>Stephen Kleene</strong> como un elemento de su trabajo fundacional en la teor√≠a de aut√≥matas y computabilidad. Actualmente, las expresiones regulares son ampliamente utilizadas por distintos tipos de programas ( editores de texto, programas de linea de comando,etc.</p><ol><li><p>Alfabeto</p><ul><li><strong>Alfabeto</strong> es un conjunto finito de s√≠mbolos. Se denomina con una letra griega Œ£.<ol><li>Œ£1={0,1} ‚Üí alfabeto binario</li><li>Œ£2={a,b} ‚Üí alfabeto formado por las letras a y b</li><li>Œ£3={I,V,X,L,C,D,M} ‚Üí alfabeto formados por los s√≠mbolos de los n√∫meros romanos</li><li>ASCII ‚Üí es un alfabeto, cumple con la definici√≥n</li><li>UTF-8 ‚Üí es un alfabeto tambi√©n.</li></ol></li></ul></li><li><p>Cadena</p><ul><li><p>Una <strong>cadena</strong> sobre un alfabeto es una secuencia finita de s√≠mbolos que se extraen de un determinado alfabeto. Normalmente en teor√≠a del lenguaje los t√©rmino &quot;palabra&quot; y &quot;oraci√≥n&quot; se utilizan como sin√≥nimos.</p></li><li><p>Una cadena se denota con la letra <em>s</em>.</p></li><li><p>Todas las cadenas de determinada longitud <strong>k</strong> que se pueden construir con un alfabeto Œ£ se representan convencionalmente Œ£<sup>k</sup></p></li><li><p>Por ejemplo, dado el alfabeto Œ£= {a, b}, se dan las siguientes extensiones:</p><ul><li>Œ£<sup>0</sup> = {‚àÖ}</li><li>Œ£<sup>1</sup> = {a, b}</li><li>Œ£<sup>2</sup> = {aa, ab, ba, bb}</li><li>Œ£<sup>3</sup> = {aaa, aab, abb, aba, bbb, bba, baa, bab}‚Ä¶</li></ul></li><li><p>Para representar el conjunto de todas las cadenas posibles que se pueden obtener a partir de un alfabeto Œ£ se usa la notaci√≥n Œ£‚àó. En t√©rminos de teor√≠a de conjuntos, Œ£‚àó = {Œ£<sup>0</sup> ‚à™ Œ£<sup>1</sup> ‚à™ Œ£<sup>2</sup> ‚à™ Œ£<sup>3</sup> ‚à™ Œ£ ^{4} ‚à™ ‚Ä¶}</p></li><li><p>La longitud de una cadena |s|.</p></li><li><p>La cadena vac√≠a se representa por Œµ, cuya longitud es cero.</p></li></ul></li><li><p>Lenguaje</p><p>Un <strong>lenguaje</strong> es cualquier conjunto contable de cadenas sobre alg√∫n alfabeto fijo.</p><ul><li><p>Operaciones m√°s importantes en los lenguajes son:</p><ul><li><p><strong>Uni√≥n</strong>: es la misma operaci√≥n que se realiza con los conjuntos.</p></li><li><p><strong>Concatenaci√≥n</strong>: La concatenaci√≥n de lenguajes es cuando se concatenan todas las cadenas que se forman al tomar la primer cadena del primer lenguaje y una cadena del segundo lenguaje , en todas las formas posibles.</p></li><li><p><strong>Clausura Positiva</strong>: de un lenguaje L, se denota como L(s<sup>+</sup>). En t√©rminos de teor√≠a de conjuntos, Œ£+ = { Œ£<sup>1</sup> ‚à™ Œ£<sup>2</sup> ‚à™ Œ£<sup>3</sup> ‚à™ Œ£<sup>4</sup> ‚à™ ‚Ä¶}</p></li><li><p>La <strong>Clausura de Kleene</strong>: de un lenguaje L, se denota como L(s<sup>‚àó</sup>). En t√©rminos de teor√≠a de conjuntos, Œ£‚àó = {Œ£<sup>0</sup> ‚à™ Œ£<sup>1</sup> ‚à™ Œ£<sup>2</sup> ‚à™ Œ£<sup>3</sup> ‚à™ Œ£<sup>4</sup> ‚à™‚Ä¶}</p></li></ul></li></ul></li><li><p>Expresi√≥n regular</p><p>Una <strong>expresi√≥n regular</strong> <em>s</em> es una cadena que denota L(s), un conjunto de cadenas derivados a partir de un alfabeto Œ£. L(s) es conocido como &quot;Lenguaje de s&quot;</p><p>L(s) se define inductivamente con los siguientes casos base:</p><ol><li><p>Si <strong>a</strong> es un s√≠mbolo que pertenece a Œ£, entonces <strong>a</strong> es una expresi√≥n regular, y L(a)={a}, es decir el lenguaje con una cadena de longitud uno, con <em>a</em> en su √∫nica posici√≥n</p></li><li><p>Œµ es una expresi√≥n regular, y L(Œµ) = {Œµ}, es decir el lenguaje cuyo √∫nico miembro es la cadena vac√≠a.</p></li></ol><p>hay cuatro partes que constituyen la inducci√≥n,mediante la cual las expresiones regulares m√°s grandes se construyen a partir de las m√°s peque√±as. Entonces, para cualquier expresi√≥n regular <em>s</em> y <em>t</em>,y denotan a los lenguajes L(s) y L(t) :</p><ol><li><p>(s)|(t) es una Expresi√≥n Regular tal que L(s|t)=L(s) U L(t).</p></li><li><p>(s)(t) es una expresi√≥n regular tal que L(st) contiene todas las cadenas formadas por la concatenaci√≥n de una cadena de L(s) seguida por una cadena de L(t).</p></li><li><p>(s)<sup>‚àó</sup> es una expresi√≥n regular tal que ( L(s)<sup>*</sup> )= L(s) concatenado cero o muchas veces.</p></li><li><p>(s) es una expresi√≥n regular que denota al lenguaje L(s)</p></li></ol><p>Tener en cuenta que:</p><ol><li>El operador unario ‚àó tiene la precedencia m√°s alta y es asociativo a la izquierda.</li><li>La concatenaci√≥n tiene la segunda precedencia m√°s alta y es asociativa a la izquierda.</li><li>| tiene la precedencia m√°s baja y es asociativa a la izquierda</li></ol><p>recordar:</p><table><thead><tr><th>Propiedad</th><th>Ejemplo</th></tr></thead><tbody><tr><td>asociatividad</td><td>a|(b|c) = (a|b)|c</td></tr><tr><td>Conmutatividad</td><td>a|b = b|a</td></tr><tr><td>distribuci√≥n</td><td>a(b|c)= ab|ac</td></tr><tr><td>idempotencia</td><td>a** = a*</td></tr></tbody></table><ul><li><p>Desde Kleene se han ampliado varios operadores para mejorar la habilidad de especificar patrones, algunos de ellos son :</p><ol><li><p>Una o mas instancias. El operador unario post-fijo <strong>+</strong> representa la clausura positiva de una expresi√≥n regular.</p></li><li><p>Cero o una instancia. El operador post-fijo <strong>?</strong>. Es equivalente a r|Œµ , o dicho de otra forma L(r?)= L(r) U L(Œµ)</p></li><li><p>Clases de caracteres. [a-z] rango de letras min√∫sculas . Otra forma es utilizando el operador |</p></li></ol></li></ul></li><li><p>Ejemplos</p><ul><li>Un identificador es una secuencia de letras may√∫sculas y n√∫meros, pero un numero nunca puede estar primero:</li></ul><table><thead><tr><th>expresi√≥n regular</th><th>[A-Z]+([A-Z] | [0-9] )‚àó</th></tr></thead><tbody><tr><td>verifican la rexp</td><td>PRINT</td></tr><tr><td></td><td>MODE5</td></tr><tr><td></td><td></td></tr><tr><td>NO VERIFICAN</td><td>print</td></tr><tr><td></td><td>5contador</td></tr></tbody></table><ul><li><p>Un n√∫mero es una secuencia de d√≠gitos con un punto decimal opcional. Como nota el punto decimal debe tener d√≠gitos a ambos lados:</p><table><thead><tr><th>expresi√≥n regular</th><th>[A-Z]+([A-Z] | [0-9] )‚àó</th></tr></thead><tbody><tr><td>verifican la rexp</td><td>PRINT</td></tr><tr><td></td><td>MODE5</td></tr><tr><td></td><td></td></tr><tr><td>NO VERIFICAN</td><td>print</td></tr><tr><td></td><td>5contador</td></tr></tbody></table></li></ul><p>Tabla de expresiones regulares comunes:</p><table><thead><tr><th>Expresi√≥n</th><th>Descripci√≥n</th></tr></thead><tbody><tr><td>.</td><td>Any character is required.</td></tr><tr><td>a</td><td>The character a is required.</td></tr><tr><td>[abcdef]</td><td>Any character in the set abcdef is required.</td></tr><tr><td>[a-f]</td><td>Any character in the range a to f is required.</td></tr><tr><td>a?</td><td>The character a is optional.</td></tr><tr><td>a*</td><td>Zero or more of the character a are required.</td></tr><tr><td>a+</td><td>One or more of the character a are required.</td></tr><tr><td>\^</td><td>The start of input is required.</td></tr><tr><td>\$</td><td>The end of input is required.</td></tr></tbody></table></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="reconocimiento-de-tokens"></a>Reconocimiento de Tokens<a class="hash-link" href="#reconocimiento-de-tokens" title="Direct link to heading">#</a></h3><ul><li>Una vez con capacidad para expresar patrones usando expresiones regulares es necesario estudiar como tomar todos los patrones para todos los tokens necesarios. Adem√°s, construir una pieza de c√≥digo que examine la cadena de entrada y busque un prefijo que sea un lexema que coincida con esos patrones.</li><li>Por ejemplo:</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">inst -&gt; if expr then instr</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      | if expr then instr else instr </span></span><span class="token-line" style="color:#393A34"><span class="token plain">      | &amp;epsilon;                     </span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">expr -&gt; term oprel term</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      | term |</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">term -&gt; id </span></span><span class="token-line" style="color:#393A34"><span class="token plain">     | numero </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Las terminales de la gram√°tica, que son <strong>if</strong>, <strong>then</strong>, <strong>else</strong>, <strong>oprel</strong> (operaci√≥n relacional), <strong>id</strong>, <strong>numero</strong> corresponden a los nombres de los tokens que el analizador l√©xico respecta. A continuaci√≥n se escriben los patrones para estos tokens que se describen como expresiones regulares:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">digito   -&gt; [0-9] </span></span><span class="token-line" style="color:#393A34"><span class="token plain">digitos  -&gt; digito+ </span></span><span class="token-line" style="color:#393A34"><span class="token plain">numero   -&gt; digitos(.disgitos)? (E[=-]? digitos) ? </span></span><span class="token-line" style="color:#393A34"><span class="token plain">letra    -&gt; [A-Za-z]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">id       -&gt; letra (letra &amp;vert; digito)\* </span></span><span class="token-line" style="color:#393A34"><span class="token plain">if       -&gt; T_IF </span></span><span class="token-line" style="color:#393A34"><span class="token plain">then     -&gt; T_THEN </span></span><span class="token-line" style="color:#393A34"><span class="token plain">else     -&gt; T_ELSE </span></span><span class="token-line" style="color:#393A34"><span class="token plain">oprel    -&gt; &lt; | &gt; | &lt;= | &gt;= | = | &lt;&gt; </span></span><span class="token-line" style="color:#393A34"><span class="token plain">ws       -&gt; ( \n\n)+</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="aut√≥matas-finitos"></a>Aut√≥matas Finitos<a class="hash-link" href="#aut√≥matas-finitos" title="Direct link to heading">#</a></h3><p>(Dou:p15)(Hop:31)</p><ul><li><p>Se dice que un <strong>Aut√≥mata Finito</strong> es una <strong>m√°quina abstracta que puede ser utilizada para representar ciertas formas de c√≥mputo</strong>. Gr√°ficamente un AF consiste en un n√∫mero de <strong>estados</strong> y <strong>un numero de v√©rtices</strong> entre esos estados. Cada uno de estos v√©rtices se etiqueta con uno de los s√≠mbolos de un alfabeto.</p></li><li><p>La m√°quina siempre comienza en el estado S<sub>0</sub>. Para cada s√≠mbolo de entrada que se presente al AF, este se mueve al estado indicado por el v√©rtice con la misma etiqueta que el s√≠mbolo de entrada.</p></li><li><p>Algunos estados de AF son conocidos como <strong>accepting states</strong> (estados de aceptaci√≥n o finales) estos se marcan con un doble circulo.</p></li><li><p>Si un AF se encuentra en un estado de aceptaci√≥n despu√©s de consumir todo el input, entonces se dice que el AF acepta el input. Se dice que rechaza el string de entrada si este termina en un estado no final.</p></li><li><p>Cada Expresi√≥n Regular puede ser transformada en un Aut√≥mata Finito y viceversa.</p></li><li><p>Ejemplo1: palabra reservada <strong>for</strong>:</p></li></ul><p><img alt="img" src="data:image/png;base64,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"></p><ul><li>Ejemplo2: Reconocimiento de identificadores [a-z][a-z0-9]+</li></ul><p><img alt="img" src="/assets/images/automata-id-2f7b9d5fc6d1b0ea623e446bb85f27e1.png"></p><ul><li>Ejemplo3: AF para reconocer n√∫meros de la forma ([1-9][0-9]‚àó)|0:</li></ul><p><img alt="img" src="/assets/images/automata-numbers-c267dfb780e2706d49cf68642c07cf86.png"></p><ol><li><p>Aut√≥matas Finitos Deterministas</p><p>(lou:p49) Un <strong>aut√≥mata finito determinista</strong> o <strong>DFA</strong> <em>M</em> se compone de un alfabeto Œ£, un conjunto de estados D, una funci√≥n de transici√≥n T:S x Œ£ -&gt; S, un estado inicial S<sub>0</sub> ‚àà S y un conjunto de estados de aceptaci√≥n A perteneciente a S.</p></li></ol><p>El lenguaje aceptado por <em>M</em>, se escribe como L(M), se define como el conjunto de cadenas de caracteres c<sub>1</sub>c<sub>2</sub>‚Ä¶.c<sub>n</sub> con cada c<sub>i</sub> ‚àà Œ£, tal que existen estados S<sub>1</sub>=T(s<sub>1</sub>,c<sub>1</sub>), S<sub>2</sub>=T(s<sub>2</sub>,c<sub>2</sub>)‚Ä¶. S<sub>n</sub>=T(s<sub>n</sub>,c<sub>n</sub>) con S<sub>s</sub> un elemento de A, es decir un estado de aceptaci√≥n.</p><ul><li><p>S x Œ£ se refiere al producto cartesiano</p></li><li><p>La funci√≥n T registra transiciones de estado: T(s,c)=s&#x27;</p><p><img alt="img" src="data:image/png;base64,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"></p></li><li><p>La aceptaci√≥n como la existencia de una secuencia de estados S<sub>1</sub>‚Ä¶..S<sub>n</sub> siendo S<sub>n</sub> un estado de aceptaci√≥n.</p><p>En otras palabras:</p><p>un DFA es un aut√≥mata finito que adem√°s es un sistema determinista; es decir:</p><ul><li>para cada estado en que se encuentre el aut√≥mata, y con cualquier s√≠mbolo del alfabeto le√≠do, <strong>existe siempre no m√°s de una transici√≥n posible desde ese estado y con ese s√≠mbolo</strong>.</li></ul></li></ul><ol><li><p>Ejemplo de DFA:</p><p><img alt="img" src="/assets/images/automata-finito-deterministico-ejemplo-2fd134adc3e95a7652cf02d514cb8dc5.png"></p><ul><li><p>S={S0,S1,S2} (conjunto de estados)</p></li><li><p>S0 es el estado inicial</p></li><li><p>Œ£={0,1} (alfabeto)</p></li><li><p>A={S2} (conjunto de estados de aceptaci√≥n)</p></li><li><p>T funci√≥n de transici√≥n: T(S0,0 )= S1 T(S0, 1)= S0 T(S1, 0)= S1 T(S1, 1)= S2 T(S2, 0)= S2 T(S2, 1)= S2</p></li></ul></li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">  Se define el aut√≥mata finito deterministico en funci√≥n de una qu√≠ntupla de la siguiente forma M=(S, S0, Œ£, A, T)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ol start="2"><li><p>La funci√≥n de transici√≥n extendida y la tabla de transiciones:</p><p>Sea el siguiente aut√≥mata :</p><p><img alt="img" src="/assets/images/automata-finito-deterministico-ejemplo-2fd134adc3e95a7652cf02d514cb8dc5.png"></p><p>definido formalmente por la qu√≠ntupla :</p><p>A=(Q, Œ£, Œ¥, q<sub>0</sub>, F)</p><p>La tabla de transici√≥n se arma, poniendo haciendo una tabla de doble entrada entre los s√≠mbolos del alfabeto y los estados del aut√≥mata.</p><p>La tabla de transici√≥n del aut√≥mata viene dada por:</p><table><thead><tr><th></th><th>0</th><th>1</th></tr></thead><tbody><tr><td>-&gt; S<sub>0</sub></td><td>S<sub>1</sub></td><td>S<sub>0</sub></td></tr><tr><td>S<sub>1</sub></td><td>S<sub>1</sub></td><td>S<sub>2</sub></td></tr><tr><td>*  S<sub>2</sub></td><td>S<sub>2</sub></td><td>S<sub>2</sub></td></tr></tbody></table><p>Esta tabla puede usarse para verificar si una cadena pertenece al lenguaje, por ejemplo:11010</p><p>A su vez se define a la <strong>funci√≥n de transici√≥n extendida</strong> \<sup>Œ¥</sup>, llamada delta hat o delta sombrero. Esta es una funci√≥n de dos variables \<sup>Œ¥</sup>(q<sub>0</sub>,w), donde w es una cadena.</p><p>Sea w=11011 entonces</p><p>\<sup>Œ¥</sup>(q<sub>0</sub>,w)=q<sub>2</sub></p></li></ol><ol start="2"><li><p>Aut√≥matas Finito No Deterministas</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Un **Aut√≥mata Finito No Determinista** o **NFA** M consta de un alfabeto &amp;Sigma;, un conjunto de estados S, una funci√≥n de transici√≥n T: S x ( &amp;Sigma; &amp;cup; {&amp;epsilon;} ) &amp;rarr; \wp()(S), as√≠ un estado de inicio s&lt;sub&gt;0&lt;/sub&gt; de S y un conjunto de estados de aceptaci√≥n A de S.</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">El Lenguaje aceptado por M, escrito por L(M), se define como el conjunto de cadenas de caracteres c&lt;sub&gt;1&lt;/sub&gt;c{2}&amp;#x2026;c&lt;sub&gt;n&lt;/sub&gt; con cada c&lt;sub&gt;i&lt;/sub&gt; de &amp;sigma; &amp;isin; (&amp;epsilon;) tal que existen estados s&lt;sub&gt;1&lt;/sub&gt; en T(s&lt;sub&gt;0&lt;/sub&gt;,c1) &amp;#x2026;.. con s&lt;sub&gt;n&lt;/sub&gt; un elemento de A.</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">-   ¬øD√≥nde est√° la diferencia?</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">La diferencia est√° en que para un mismo s√≠mbolo del alfabeto existen m√∫ltiples posibles transiciones, o incluso puede no existir transici√≥n. Por ello el aut√≥mata se denomina **No Determinista**.</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">La Clave est√° en la funci√≥n de transici√≥n : T: S x ( &amp;Sigma; &amp;cup; {&amp;epsilon;} ) &amp;rarr; \wp()(S),</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">1.  Ejemplo de NFA</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ![img](../images/automata-finito-no-deterministico-ejemplo.png)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Analisis de hilos en un NFA, dada la cadena: 00101 realizar el an√°lisis de hilos.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ![img](../images/hilo-nfa.png)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">2.  La tabla de transiciones:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Si se tiene en cuenta la definici√≥n formal de un **automata finito no determinista**:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    A=(Q, &amp;Sigma;, &amp;de lta;, q&lt;sub&gt;0&lt;/sub&gt;,F), donde:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    1. Q es un conjunto de estados.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    2. &amp;Sigma; es un conjunto finito de s√≠mbolos de entrada, un alfabeto.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    3. q&lt;sub&gt;0&lt;/sub&gt;, un elemento de Q, que es el estado inicial.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    4. F, un subconjunto de Q de estados de aceptaci√≥n.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    5. &amp;delta; la funci√≥n de transici√≥n que toma un estado de Q y un s√≠mbolo de &amp;Sigma; como argumentos y devuelve un **subconjunto de Q**.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Dado el ejemplo anterior, obtener la tabla de transiciones para w=00101:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ![img](../images/automata-finito-no-deterministico-ejemplo.png)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    |      | 0    | 1  |</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    | --- | ----- | -- |</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    | &amp;larr; S&lt;sub&gt;0&lt;/sub&gt;   | {S&lt;sub&gt;0&lt;/sub&gt;,S&lt;sub&gt;1&lt;/sub&gt;} | {S&lt;sub&gt;0&lt;/sub&gt;} |</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>| S<sub>1</sub>         | ‚àÖ                   | {S<sub>2</sub>  |
| ‚àó S<sub>2</sub> | ‚àÖ                       | emptyset        | |</p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="un-poco-de-c√≥digo"></a>Un Poco de C√≥digo<a class="hash-link" href="#un-poco-de-c√≥digo" title="Direct link to heading">#</a></h3><p>(lou)</p><ol><li><p>Un Token:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">typedef enum {IF, THEN, ELSE , PLUS,NUM, ID  } token_type;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    token_type token_val;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    char * string_val;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int num_val;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} TOKEN;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>o</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">typedef enum {IF, THEN, ELSE , PLUS,NUM, ID  } token_type;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    token_type token_val;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    union{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    char * string_val;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int num_val;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } atributos;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">} TOKEN;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">2.  La Tabla de S√≠mbolos:</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    (Ben:65) A medida que se va realizando el proceso de compilaci√≥n es necesario buscar nombres en la **Tabla de S√≠mbolos**, para ver si un identificador ha sido declarado. Esto adem√°s tiene que ser hecho de una forma muy eficiente, un arreglo de registro o por una lista enlazada son una estructura muy ineficiente para las b√∫squedas, para ello es necesario y una **Tabla de Hash Abierto**:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ```C</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct symbol_table{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct symbol_table* siguiente;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        char*                nombre;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int                  tipo;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int                  block_no;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int                  direccion;              </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ol start="3"><li><p>Un lexer</p><p>(dra,lou)</p><p>Para mostrar como es la arquitectura de un analizador l√©xico a partir de aut√≥matas se utilizar√° el siguiente aut√≥mata que representa el reconocimiento de las operaciones de relaci√≥n:</p><p><img alt="img" src="/assets/images/automata-finito-to-lexer-58ac3f75288e7e95ac9e9c2b02df70ed.png"></p><p>tener en cuenta que el s√≠mbolo ‚àó implica que se debe retroceder la entrada en un caracter.</p><p><img alt="img" src="/assets/images/automata-finito-to-lexer-58ac3f75288e7e95ac9e9c2b02df70ed.png"></p><p>para implementar un analizador gr√°fico a partir de un automata, en primer lugar se debe pensar en una variable llamada <strong>estado</strong>, que contenga el <strong>estado actual</strong> en el que se encuentra el aut√≥mata. Una instrucci√≥n <strong>switch</strong> que est√© basada en el valor del estado y para cada uno de estos valores se ejecutara el c√≥digo necesario para cada uno de los estados. Un ejemplo en C:</p></li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    TOKEN * ObtenerOpRel(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        TOKEN * token_ret= malloc(TOKEN);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(1){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        switch (estado) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case 0: c=sig_char();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (c == &#x27;&lt;&#x27;) estado =1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                else if (c == &#x27;=&#x27;) estado = 5;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                else if (c == &#x27;&gt;&#x27;) estado = 6;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                else error(); /*el lexema no es un operacion relacional */    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case 1:  ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case 2:  ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case 3:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case 8: retroceder();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                token_ret-&gt;val= GD;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return (token_ret);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Dado que esto √∫ltimo se debe realizar por cada tipo de token, el programar a mano un analizador l√©xico de un lenguaje de programaci√≥n se torna una cuesti√≥n muy compleja. Por ello normalmente se utilizan <strong>Generadores de Analizadores L√©xicos</strong></p></div><footer class="docusaurus-mt-lg"><div class="row"><div class="col"><a href="https://github.com/compiladores/compiladores.github.io/edit/master/docs/versioned_docs/version-2021_2/teoricas/03-analisis-lexico/01-intro.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/2021_2/teoricas/proc-lenguaje"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">¬´ Procesadores de Lenguaje</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/2021_2/teoricas/analisis-lexico/analisis-lexico"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Generadores de Analizadores L√©xicos ¬ª</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introducci√≥n--dragon-3" class="table-of-contents__link">Introducci√≥n  dragon-3</a></li><li><a href="#expresiones-regulares-introducci√≥n" class="table-of-contents__link">Expresiones Regulares: Introducci√≥n</a></li><li><a href="#reconocimiento-de-tokens" class="table-of-contents__link">Reconocimiento de Tokens</a></li><li><a href="#aut√≥matas-finitos" class="table-of-contents__link">Aut√≥matas Finitos</a></li><li><a href="#un-poco-de-c√≥digo" class="table-of-contents__link">Un Poco de C√≥digo</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Material</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/labs/intro">Laboratorios</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Hecho para Ud.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.7e3c6e03.js"></script>
<script src="/assets/js/main.4a390fc5.js"></script>
</body>
</html>
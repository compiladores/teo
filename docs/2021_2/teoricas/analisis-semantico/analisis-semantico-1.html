<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">Analisis Semantico | Lenguajes y Compiladores</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-semantico/analisis-semantico-1"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="2021_2"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-2021_2"><meta data-react-helmet="true" property="og:title" content="Analisis Semantico | Lenguajes y Compiladores"><meta data-react-helmet="true" name="description" content="Análisis Semántico"><meta data-react-helmet="true" property="og:description" content="Análisis Semántico"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-semantico/analisis-semantico-1"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-semantico/analisis-semantico-1" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-semantico/analisis-semantico-1" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.a91fdf40.css">
<link rel="preload" href="/assets/js/runtime~main.d9842b2b.js" as="script">
<link rel="preload" href="/assets/js/main.eb36591c.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Lenguajes y Compiladores</b></a><a class="navbar__item navbar__link" href="/docs/2021_2/labs/intro">Laboratorios</a><a class="navbar__item navbar__link" href="/docs/2021_2/practicas/intro">Prácticas</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/2021_2/teoricas/intro">Teóricas</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/docs/2021_2/labs/Trabajo Práctico">2021_2</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/teoricas/analisis-semantico/analisis-semantico-1">este cuatri</a></li><li><a aria-current="page" class="dropdown__link navbar__link--active" href="/docs/2021_2/teoricas/analisis-semantico/analisis-semantico-1">2021_2</a></li></ul></div><a href="https://github.com/compiladores" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/2021_2/teoricas/intro">Compiladores</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/2021_2/teoricas/proc-lenguaje">Procesadores de Lenguaje</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-lexico</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-sintactico</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">analisis-semantico</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/2021_2/teoricas/analisis-semantico/analisis-semantico-1">Analisis Semantico</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/2021_2/teoricas/analisis-semantico/analisis-semantico-Tipos-de-datos">Analisis Semantico</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/2021_2/teoricas/bibliografia">Bibliografia</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">generacion-ir</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="alert alert--warning margin-bottom--md" role="alert"><div>This is documentation for Lenguajes y Compiladores <b>2021_2</b>, which is no longer actively maintained.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/docs/teoricas/analisis-semantico/analisis-semantico-1">latest version</a></b> (este cuatri).</div></div><div class="docItemContainer_33ec"><article><span class="badge badge--secondary">Version: 2021_2</span><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1>Analisis Semantico</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="análisis-semántico"></a>Análisis Semántico<a class="hash-link" href="#análisis-semántico" title="Direct link to heading">#</a></h2><ul><li><p>El <strong>análisis semántico</strong> es la fase en la cual el compilador calcula la información adicional necesaria para la compilación una vez que se conoce la estructura sintáctica de un programa.</p></li><li><p>Esta fase se conoce como <strong>análisis semántico</strong> debido a que involucra el calculo de información que sobrepasa las capacidades de las gramáticas libres de contexto y los algoritmos de análisis sintáctico estándar, por lo que no se considera sintaxis.</p></li><li><p>La información calculada también esta estrechamente relacionada con el significado final, o semántica, del programa que se traduce.</p></li><li><p>Como el análisis que realiza el compilador es estático por definición, el análisis semántico también se conoce como <strong>análisis semántico estático</strong>.</p><ul><li>En un lenguaje típico estáticamente tipado como C, en análisis semántico involucra la construcción de una tabla de símbolos para mantenerse al tanto de los significados de los nombres establecidos en las declaraciones, inferir los tipos y verificarlos en las expresiones y sentencias con el fin de determinar la exactitud dentro de las reglas de tipos del lenguaje.</li></ul></li></ul><p>El análisis semántico se divide en dos categorías:</p><ul><li><p>La primera es el análisis de un programa que requiere las reglas del lenguaje de programación para establecer su exactitud y garantizar una ejecución adecuada. La complejidad de este tipo de análisis varia según lo requerido por la definición del lenguaje. En lenguajes orientados en forma dinámica tales como LISP y SMALLTALK pueden no haber análisis semántico estático mientras que en lenguajes como ADA existen fuertes requerimientos que debe cumplir un programa para ser ejecutable.</p></li><li><p>La segunda categoría de análisis semántico es el análisis realizado por un compilador para mejorar la eficiencia de ejecución del programa traducido. Esta clase de análisis, por lo regular, se incluye en análisis de optimización o técnicas de mejoramiento de código. El análisis semántico a diferencia del análisis léxico y del análisis sintáctico no posee generadores automáticos de analizadores semánticos, como el caso de lex o yacc.</p></li><li><p>En el análisis sintáctico existen tres componentes importantes</p><ul><li><p>La tabla de símbolos</p></li><li><p>La verificación y control de tipos</p></li><li><p>Las gramáticas con atributos</p></li></ul></li></ul><p>Estas últimas son más útiles para los lenguajes que obedecen el principio de la <strong>semántica dirigida por sintaxis</strong>, la cual asegura que el contenido semántico de un programa se encuentra estrechamente relacionado con su sintaxis. Todos los lenguajes modernos tienen esta propiedad.</p><ul><li><p>Normalmente quien escribe un compilador casi siempre debe construir una gramática con atributos a mano a partir del manual del lenguaje, ya que rara vez la da el diseñador del lenguaje.</p></li><li><p>Los algoritmos para la implementación del análisis semántico tampoco son tan claramente expresables como los algoritmos de análisis sintáctico.</p></li><li><p>Existe un problema adicional causado por la temporalidad del análisis durante el proceso de compilación. Si el análisis semántico se puede suspender hasta que todo el análisis sintáctico este completo, entonces la tarea de implementar el análisis semántico se vuelve considerablemente más fácil. Y consiste en esencia en la especificación de orden para el recorrido del árbol sintáctico, junto con los cálculos a realizar cada vez que se encuentra un nodo en el recorrido. Sin embargo, esto implica que el compilador debe realizar varias pasadas de análisis. Si por otra parte el compilador necesita realizar todas sus operaciones (incluyendo la generación de código en un solo paso), entonces la implementación del análisis semántico se convierte en mucho mas que un proceso a propósito para encontrar un orden correcto y un método para calcula la información semántica. En la actualidad los escritores de compiladores utilizan varias pasadas para simplificar los procesos de análisis semántico y generación de código.</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="la-tabla-de-símbolos"></a>La Tabla de Símbolos<a class="hash-link" href="#la-tabla-de-símbolos" title="Direct link to heading">#</a></h3><p>La tabla de símbolos es el principal atributo heredado en un compilador, y, después del árbol sintáctico, también forma la principal estructura de datos. Si bien la tabla de símbolos esta estrechamente relacionada con el análisis sintáctico y el análisis léxico, los cuales pueden consultarla para resolver ambigüedades.</p><p>Pero sin embargo, en ciertos lenguajes como Ada y PASCAL, es posible e incluso razonable posponer las operaciones de la tabla de símbolos hasta después de realizar en análisis sintáctico completo, es decir cuando se sabe que el programa que se esta traduciendo es sintácticamente correcto.</p><ul><li>Principales operaciones en la tabla de símbolos:<ul><li>Inserción: Se utiliza para almacenar la información proporcionada por las declaraciones de nombre cuando se procesan estas declaraciones.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">insert(name, record);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>Búsqueda: Es necesaria para recuperar la información asociada con un nombre cuando éste se utiliza en el código.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">look_up(name);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>Eliminación: Es necesaria para eliminar la información proporcionada por una declaración cuando ya no se aplica.</li></ul><p>La propiedades de estas operaciones son dictadas por las reglas del lenguaje de programación que se esta traduciendo. En particular la información que se necesita almacenar en la tabla de símbolos está en función de la estructura y propósito de las declaraciones.</p><p>La información que incluye puede ser:</p><ul><li>Tipo de Dato</li><li>Lexema</li><li>Posición</li><li>Ámbito (scope): información de la aplicabilidad.</li><li>Información acerca de la ubicación posible en la memoria.</li></ul><ol><li><p>Estructura de la Tabla de Símbolos</p><p>La Tabla de Símbolos en un compilador es una estructura de datos llamada <strong>diccionario o tabla de hash</strong>, obviamente por sus bondades en los tiempos de acceso a los datos. Las operaciones sobre la tabla de Símbolos deben ser lo más eficientes posible.</p><p>Normalmente se utiliza un <strong>diccionario con resolución de colisiones de tipo abierto</strong>:</p><p><img alt="img" src="/assets/images/tabla-de-simbolos-a386dace5c4457cd2aabdcc193cc50d4.png"></p><p>Obviamente en este punto se debe tener en cuenta todo lo que se conoce sobre la implementación de diccionarios o tablas de hash: correcta elección de la función de hash, la longitud inicial del diccionario, etc. Todo ese análisis debiera realizarse con los conocimientos sobre la estructura de dato en cuestión.</p></li><li><p>Declaraciones</p><p>El comportamiento de la tabla de símbolos depende mucho de las propiedades de las declaraciones del lenguaje que se está traduciendo. ¿Que se inserta?</p><p>Existen cuatro clases básicas de declaraciones:</p><ul><li><p>Declaraciones de Constantes</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">const int SIZE = 199;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li><li><p>Declaraciones de Tipos</p></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">struct Entry</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      char * name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      int count;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      struct Entry * next;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  typedef struct Entry * Entry_ptr;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>Declaraciones de Variables</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int x;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int vector[10];</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>Declaraciones de Funciones</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int funcion (int x, int y);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li><li><p>Un Ejemplo</p><p>A continuación se muestra una posible implementación para crear una entrada en una tabla de símbolos en C:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">typedef enum { SYMBOL_LOCAL, SYMBOL_PARAM, SYMBOL_GLOBAL, SYMBOL_FUNCTION, SYMBOL_CONST} symbol_t;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">struct symbol</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{ </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  symbol_t kind;        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  struct type *type;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  char *name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  int  which;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">struct symbol * symbol_create(symbol_t kind, struct type * type, char * name)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct symbol *s = malloc(sizeof(*s));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    s-&gt;kind=kind;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    s-&gt;type=type;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    s-&gt;name=name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return s;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>kind: indica si un símbolo es una variable local, función, variable global, etc.</li><li>type: apunta a una estructura de dato que indica el tipo de la variable.</li><li>name: el nombre de la variable.</li><li>which: la posición ordinal de la variable local o del parámetro en una función.</li></ul></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="reglas-de-ámbito-y-estructura-de-bloques"></a>Reglas de Ámbito y Estructura de Bloques<a class="hash-link" href="#reglas-de-ámbito-y-estructura-de-bloques" title="Direct link to heading">#</a></h3><p>Las reglas de ámbito en los lenguajes de programación varían mucho, pero existen varias reglas que son comunes a muchos lenguajes.</p><ul><li><strong>Declaración antes de uso</strong>: Es una regla común utilizada en C y en PASCAL que requiere que se declare un nombre en el texto del programa antes que cualquier referencia al nombre. Esta declaración antes del uso permite construir la tabla de símbolos a medida que el análisis sintáctico continúa y que las búsquedas se realicen tan pronto como se encuentra una referencia de nombre en el código; si la búsqueda falla es que ha ocurrido una violación de la declaración antes del uso. Este tipo de regla fomenta compilaciones de una sola fase</li><li><strong>Estructura de bloques</strong>: Es una propiedad común de los lenguajes modernos. Un bloque en un lenguaje de programación es cualquier construcción que pueda contener declaraciones. En C los bloques son unidades de compilación, es decir las declaraciones de procedimientos y funciones y las sentencias compuestas (encerradas entre llaves). En un lenguaje orientado a objetos la declaración de clases también son bloques. Un lenguaje esta estructurado en bloques si permite la anidación de bloques dentro de otros bloques, y si el ámbito de declaraciones en un bloque esta limitado a ese y otros bloques contenidos en el mismo, sujeto a la <strong>regla de anidación mas próxima</strong>: dadas varias declaraciones diferentes para el mismo nombre, la declaración que se aplica a una referencia es la única en ese bloque anidado mas próximo a la referencia.<ul><li>En muchos lenguajes, como PASCAL y Ada, los procedimientos y funciones también pueden estar anidados (esto presenta un factor de complicación en el ambiente de tiempo de ejecución para tales lenguajes).</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">int i,j;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">int f(int size)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   { char i, temp;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     { double j;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     } </span></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     { char * j;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   } </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><p>Para implementar ámbitos anidados, la operación de inserción de la tabla de símbolos no debe sobrescribir declaraciones anteriores, sino que las debe ocultar temporalmente, de manera que la operación de búsqueda solo encuentre la declaración para un nombre que se haya insertado más recientemente.</p></li><li><p>La operación de eliminación no debe eliminar todas las declaraciones correspondientes a un nombre, sino sólo la más reciente, revelando cualquier declaración previa.</p></li><li><p>Existen varias alternativas posibles para la implementación de ámbitos anidados. Una solución es construir una nueva tabla de símbolos para cada ámbito y vincular las tablas desde ámbitos internos a ámbitos externos.</p></li></ul><p><img alt="img" src="/assets/images/tabla-simbolos-varios-ambitos-53ea422f9e087026c84c077e0643a1de.png"></p><ul><li>De manera adicional o alternativa, pueden necesitarse asignar un nivel de anidación o profundidad de anidación a cada ámbito y registrar en cada entrada de la tabla de símbolos el nivel de anidación de cada nombre.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="gramáticas-con-atributos"></a>Gramáticas con Atributos<a class="hash-link" href="#gramáticas-con-atributos" title="Direct link to heading">#</a></h3><ul><li>Es un formalismo para expresar semántica. </li></ul><p>  Dada una gramática libre de contexto se le agregan:</p><ul><li><p>Atributos: Estos atributos se agregan principalmente a los <strong>nodos no terminales</strong></p></li><li><p>Funciones o Acciones Semánticas: B → Ab {accion semántica}</p></li><li><p>Idea: Para cada una de las producciones de los nodos no terminales</p></li></ul><p>​      P,A,B ⇒ B.atributo1                     Son arbitrarios </p><p>​                    B.atributo2 </p><p>​                    B.atributo3</p><ul><li><p>Las gramáticas con atributos trabajan con el árbol de parsing.</p><ul><li><p>Una vez que se construye el árbol de parsing.</p></li><li><p>Se puede establecer un orden de dependencia en relación a los atributos</p></li><li><p>Existen tres clases de atributos:</p><ul><li><p><strong>Sintetizados</strong>: Son los atributos que en general suben desde el árbol, es decir, vienen de las hojas y van hacia la raíz.</p><p>E → T               E.x=f(T,y)</p><p>A → B              A.x=f(B,y)</p><p>y es un atributo de T x es un atributo de E</p></li><li><p><strong>Heredados</strong>: Es justo el caso inverso de esta situación.</p><p>A → B            B.y=f(A,x)</p><p>E → T             T.y=f(E,x)</p><p>Los atributos de T están utilizando cosas que vienen de E</p></li></ul><ul><li><strong>Inherentes</strong>: Son atributos fijos A → 0|1|2       A.x=0              &quot;HARCODEADOS&quot;</li></ul></li></ul><p>Son los generadores, van a estar generando los valores de los atributos en algún punto del árbol; generan las semillas de los valores.</p></li></ul><p>Los atributos y las acciones semánticas establecen una relación de flujo de información, en cuanto a que para ejecutar una acción semántica particular en algún momento particular, se necesitan atributos, y estos atributos provienen de diferentes lugares, ramas que los sinteticen o definiciones de las raíces heredadas.</p><p>Sobre el árbol de parsing se sobreimprime un árbol de dependencia dado por cómo se necesitan los atributos. Lo que hace falta hacer es cómo sincronizar ese doble esquema</p><p>Por un lado el árbol se va a parsear en el <strong>orden</strong> en que se van a ir determinando las derivaciones en la pila, eso depende de cómo es la gramática, el tipo de parser, etc.</p><p>Ese orden es arbitrario y viene dado por las dependencias que se establecen a través de los atributos (si son sintetizados o heredados).</p><p>Una vez que se tiene un árbol sintáctico de cómo un parser reconoce una palabra para un lenguaje, se hace un grafo que se sobrescribe por arriba del árbol de parsing y que determina una relación de dependencia, es decir, que hay que hacer primero, después, y así… dependiendo de las reglas semánticas y lo que éstas hacen.</p><p>Ejemplo:</p><p>A → AB|B</p><p>B → 0|1</p><p>Reglas semánticas que permitan obtener el equivalente decimal del numero binario dado por el lenguaje generado por la gramática.</p><p>Sea S=101</p><p>Usar LL(1)</p><ol><li>Se construye el árbol de parsing utilizando el método LL(1)</li></ol><p><img alt="img" src="/assets/images/gramatica-atributos-ejemplo-298ff7acc7008f880e8eef49ee48fdb5.png"></p><p><img alt="img" src="/assets/images/gramatica-atributos-ejemplo1-2c10b2dbd09683673ed10747253e6fb7.png"></p><ol><li>Se listan todas las producciones individual mente y se le asignan acciones y atributos:</li></ol><p>A<sub>1</sub> → A<sub>2</sub>B                  {A<sub>1</sub>.val=A<sub>2</sub>val*2 + B.val }</p><p>$$      <span class="math math-inline"><span class="katex-error" title="ParseError: KaTeX parse error: Expected &#x27;}&#x27;, got &#x27;EOF&#x27; at end of input: 1 {" style="color:#cc0000">1 {</span></span>$=$1}</p><p>A → B                        {A.val=B.val } (Se esta sintetizando el valor hacia arriba)</p><p>B → 0                        {B.val=0}</p><p>B → 1                         {B.val=1}</p><p>Atributos: </p><p>A.val </p><p>B.val</p><h3></h3></div><footer class="docusaurus-mt-lg"><div class="row"><div class="col"><a href="https://github.com/compiladores/compiladores.github.io/edit/master/docs/versioned_docs/version-2021_2/teoricas/05-analisis-semantico/01-analisis-semantico-1.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/2021_2/teoricas/analisis-sintactico/generadores"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Generadores de Analizadores Sintácticos</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/2021_2/teoricas/analisis-semantico/analisis-semantico-Tipos-de-datos"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Analisis Semantico »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#análisis-semántico" class="table-of-contents__link">Análisis Semántico</a><ul><li><a href="#la-tabla-de-símbolos" class="table-of-contents__link">La Tabla de Símbolos</a></li><li><a href="#reglas-de-ámbito-y-estructura-de-bloques" class="table-of-contents__link">Reglas de Ámbito y Estructura de Bloques</a></li><li><a href="#gramáticas-con-atributos" class="table-of-contents__link">Gramáticas con Atributos</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Material</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/labs/intro">Laboratorios</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Hecho para Ud.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.d9842b2b.js"></script>
<script src="/assets/js/main.eb36591c.js"></script>
</body>
</html>
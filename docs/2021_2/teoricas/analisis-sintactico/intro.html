<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.5">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">Parsing | Lenguajes y Compiladores</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-sintactico/intro"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="2021_2"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-2021_2"><meta data-react-helmet="true" property="og:title" content="Parsing | Lenguajes y Compiladores"><meta data-react-helmet="true" name="description" content="El Proceso de Análisis Sintáctico"><meta data-react-helmet="true" property="og:description" content="El Proceso de Análisis Sintáctico"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-sintactico/intro"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-sintactico/intro" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jisbruzzi.github.io/docs/2021_2/teoricas/analisis-sintactico/intro" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.a91fdf40.css">
<link rel="preload" href="/assets/js/runtime~main.8063297e.js" as="script">
<link rel="preload" href="/assets/js/main.93dbc1f3.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Lenguajes y Compiladores</b></a><a class="navbar__item navbar__link" href="/docs/2021_2/labs/intro">Laboratorios</a><a class="navbar__item navbar__link" href="/docs/2021_2/practicas/intro">Prácticas</a><a class="navbar__item navbar__link navbar__link--active" href="/docs/2021_2/teoricas/intro">Teóricas</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" href="/docs/2021_2/labs/Trabajo Práctico">2021_2</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/teoricas/analisis-sintactico/intro">este cuatri</a></li><li><a aria-current="page" class="dropdown__link navbar__link--active" href="/docs/2021_2/teoricas/analisis-sintactico/intro">2021_2</a></li></ul></div><a href="https://github.com/compiladores" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/2021_2/teoricas/intro">Compiladores</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/2021_2/teoricas/proc-lenguaje">Procesadores de Lenguaje</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-lexico</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">analisis-sintactico</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/2021_2/teoricas/analisis-sintactico/intro">Parsing</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/2021_2/teoricas/analisis-sintactico/LL1">Analizadores Sintácticos LL(1)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/2021_2/teoricas/analisis-sintactico/analizadores-sintacticos-ascendentes">Analizadores Sintácticos LR</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/2021_2/teoricas/analisis-sintactico/analisis-sintactico-lr">Analizadores Sintácticos</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/2021_2/teoricas/analisis-sintactico/generadores">Generadores de Analizadores Sintácticos</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">analisis-semantico</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/2021_2/teoricas/bibliografia">Bibliografia</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">generacion-ir</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="alert alert--warning margin-bottom--md" role="alert"><div>This is documentation for Lenguajes y Compiladores <b>2021_2</b>, which is no longer actively maintained.</div><div class="margin-top--md">For up-to-date documentation, see the <b><a href="/docs/teoricas/analisis-sintactico/intro">latest version</a></b> (este cuatri).</div></div><div class="docItemContainer_33ec"><article><span class="badge badge--secondary">Version: 2021_2</span><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1>Parsing</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="el-proceso-de-análisis-sintáctico"></a>El Proceso de Análisis Sintáctico<a class="hash-link" href="#el-proceso-de-análisis-sintáctico" title="Direct link to heading">#</a></h3><p>(Lou:p96)</p><ul><li>La tarea del <strong>analizador sintáctico</strong> es determinar la <strong>estructura sintáctica</strong> de un programa a partir de los tokens producidos por el <strong>analizador léxico</strong> y construir un <strong>árbol de análisis gramatical o sintáctico</strong> que represente esta estructura.</li></ul><p><img alt="img" src="/assets/images/analisis-sintactico-5585928cf7dffc36cdd9369421ce57d6.png"></p><ul><li>Básicamente la idea es la siguiente:</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">syntax_tree = parse();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><img alt="img" src="data:image/png;base64,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"></p><ul><li>Para que esto sea posible ….</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="introducción-gramáticas"></a>Introducción Gramáticas<a class="hash-link" href="#introducción-gramáticas" title="Direct link to heading">#</a></h3><p>(Aho:p191)</p><ul><li><p>Los lenguajes de programación tienen por diseño reglas precisas que describen la estructura sintáctica de los programas escritos correctamente. Así como una frase en español tiene una estructura sintáctica que hace que podamos a través de su análisis inferir su semántica. Lo mismo pasa con los lenguajes de programación como por ejemplo C.</p></li><li><p>La sintaxis de las construcciones de un de un lenguaje de programación puede especificarse mediante <strong>gramáticas libres de contexto</strong> con la notación BNF (Backus-Naur Form).</p></li><li><p>Las gramáticas ofrecen los siguientes beneficios:</p><ul><li><p>Proporcionan una especificación sintáctica precisa de un lenguaje de programación y fácil de entender.</p></li><li><p>A partir de ciertas clases de gramáticas, se puede construir de manera automática un analizador sintáctico eficiente que determine la estructura sintáctica del código fuente de un programa.</p></li><li><p>La estructura impartida a un lenguaje mediante una gramática diseñada en forma apropiada es útil para traducir código fuente en código objeto correcto, y permite detectar errores.</p></li><li><p>Las gramáticas permiten la evolución de los lenguajes a los que se les puede agregar nuevas construcciones para realizar nuevas tareas.</p></li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="convención-de-notación"></a>Convención de Notación<a class="hash-link" href="#convención-de-notación" title="Direct link to heading">#</a></h4><ol><li><p>Símbolos Terminales:</p><ol><li><p>Las primeras letras de minúsculas del alfabeto, como a, b, c</p></li><li><p>Símbolos de operadores como +,-, ∗(), etc.</p></li><li><p>Símbolos de puntuación como paréntesis, coma, punto y coma, etc.</p></li><li><p>Los dígitos 0,1,2,….,9.</p></li><li><p>Las cadenas en negrita como <strong>if</strong>, <strong>while</strong>.</p></li></ol></li><li><p>Símbolos No Terminales:</p><ol><li><p>Las Primeras Letras del Alfabeto, como, A,B,C.</p></li><li><p>La letra S que por lo general es considerado el símbolo inicial, que por lo general es la primera regla.</p></li><li><p>Los nombres en minúsculas y cursiva. <em>expr</em>, <em>term</em>  </p></li><li><p>Al hablar sobre las construcciones de programación, las letras mayúsculas pueden utilizarse para representar símbolos no terminales. Por ejemplo los no terminales para las expresiones, términos y los factores se representan como E, T y F.</p></li><li><p>Las letras mayúsculas X, Y y Z que pueden ser terminales o no terminales.</p></li><li><p>Las letras minúsculas del alfabeto , como u,v,….,z representan cadenas de terminales, normalmente vacías.</p></li><li><p>Las letras griegas minúsculas α, β, γ, representan cadenas ( posiblemente vacías) de símbolos gramaticales.</p></li></ol></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="backus-naur-form"></a>Backus-Naur Form<a class="hash-link" href="#backus-naur-form" title="Direct link to heading">#</a></h4><p>Backus normal form, es un metalenguaje usado para expresar gramáticas libres de contexto: es decir, una manera formal de describir lenguajes formales.</p><p>BNF se utiliza extensamente como notación para las gramáticas de los lenguajes de programación, etre otros, así como una notación para representar partes de las gramáticas de la lengua natural. La mayoría de los libros de textos para la teoría o la semántica del lenguaje de programación documentan el lenguaje de programación en BNF.</p><p>John Backus,  adoptó las reglas generativas de Chomsky para describir la sintaxis del nuevo lenguaje de programación IAL, conocido en la actualidad como ALGOL 58 (1959), presentando en el primer Congreso de Computación Mundial (World Computer Congress) el artículo «The syntax and semantics of the proposed international algebraic language of the Zurich ACM-GAMM Conference».</p><p>Peter Naur, en su reporte sobre ALGOL 60 de 1963, identificó la notación de Backus como la Forma Normal de Backus (Backus Normal Form), y la simplificó para usar un conjunto de símbolos menor, pero a sugerencia de Donald Knuth, su apellido fue agregado en reconocimiento a su contribución, reemplazando la palabra «Normal» por Naur, dado que no se trata de una forma normal en ningún sentido, a diferencia, por ejemplo de la Forma Normal de Chomsky.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="notación"></a>Notación<a class="hash-link" href="#notación" title="Direct link to heading">#</a></h5><p>Una especificación de BNF es un sistema de reglas de derivación, escrito como:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;simbolo&gt; ::= &lt;expresión con símbolos&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>o</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;simbolo&gt; -&gt; &lt;expresión con símbolos&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>donde:</p><ul><li>&lt;símbolo&gt; es un no terminal, </li><li>y la expresión consiste en secuencias de símbolos o secuencias separadas por la barra vertical, &#x27;|&#x27;, indicando una opción, el conjunto es una posible substitución para el símbolo a la izquierda. </li><li>Los símbolos que nunca aparecen en un lado izquierdo son terminales.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="ejemplo"></a>Ejemplo<a class="hash-link" href="#ejemplo" title="Direct link to heading">#</a></h4><p>Como ejemplo, considere este BNF para una dirección postal de los EE. UU.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dirección postal&gt; -&gt; &lt;nombre&gt; &lt;dirección&gt; &lt;apartado postal&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;nombre&gt; -&gt; &lt;personal&gt; &lt;apellido&gt; [&lt;trato&gt;] &lt;EOL&gt; </span></span><span class="token-line" style="color:#393A34"><span class="token plain">         | &lt;personal&gt; &lt;nombre&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         </span></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;personal&gt; -&gt; &lt;primer nombre&gt; | &lt;inicial&gt; &quot;.&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;direccion&gt; -&gt; [&lt;dpto&gt;] &lt;numero de la casa&gt; &lt;nombre de la calle&gt; &lt;EOL&gt;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;apartado postal&gt; -&gt; &lt;ciudad&gt; &quot;,&quot; &lt;código estado&gt; &lt;código postal&gt; &lt;EOL&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Esto se traduce a español como:
Una dirección postal <strong>consiste en</strong> un nombre, seguido por una dirección, seguida por un apartado postal.
Una parte «personal» <strong>consiste en</strong> un nombre o una inicial seguido(a) por un punto.
Un nombre consiste de: una parte personal seguida por un apellido seguido opcionalmente por una jerarquía <strong>o</strong> el trato que se la da a la persona (Jr., Sr., o número dinástico) y un salto de línea (end-of-line), <strong>o</strong> bien una parte personal seguida por un nombre (esta regla ilustra el uso de la repetición en BNFs, cubriendo el caso de la gente que utiliza múltiples nombres y los nombres medios o las iniciales).
Una dirección <strong>consiste de</strong> una especificación opcional del departamento, seguido de un número de casa, seguido por el nombre de la calle, seguido por un salto de línea (end-of-line).
Un apartado postal <strong>consiste de</strong> una ciudad, seguida por una coma, seguida por un código del estado (recuerde que es un ejemplo que ocurre en EE. UU.), seguido por un código postal y este seguido por un salto de línea (end-of-line).</p><p>Observar que muchas cosas (tales como el formato de una parte personal, de una especificación del apartamento, o código postal) están dejadas sin especificar aquí. Si es necesario, pueden ser descritas usando reglas adicionales de BNF, o dejadas como abstracción si es inaplicable para el propósito actual.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="gramáticas-libres-de-contexto"></a>Gramáticas Libres de Contexto<a class="hash-link" href="#gramáticas-libres-de-contexto" title="Direct link to heading">#</a></h3><ul><li><p>Una <strong>gramática libre de contexto</strong> es una especificación para la estructura sintáctica de un lenguaje de programación.</p></li><li><p>Es muy similar a la especificación léxica de un lenguaje utilizando expresiones regulares, excepto que una gramática libre de contexto <strong>involucra reglas de recursividad</strong>.</p></li></ul><ol><li><p>Definición</p><p>Una <strong>gramática libre de contexto</strong> tiene cuatro componentes:</p><ol><li><p>Un conjunto de símbolos <strong>terminales</strong>, son símbolos elementales del lenguaje definido por la gramática (i.e. <strong>while,for</strong>)</p></li><li><p>Un conjunto de <strong>no terminales</strong> ( variables sintácticas) que representan un conjunto de cadenas o terminales.</p></li><li><p>Un conjunto de <strong>producciones</strong>, que consiste en un no terminal llamado lado izquierdo <strong>LHS</strong>, una flecha y una secuencia de terminales y no terminales, llamado lado derecho <strong>RHS</strong>. La idea es especificar una de las formas escritas de una instrucción si el LHS representa a una instrucción y el RHS representa la forma escrita de la instrucción.</p></li><li><p>Una designación de uno de los no terminales como <strong>símbolo inicial</strong>.</p></li></ol><ul><li>Una gramática G=(V,T,P,S), donde :<ul><li>V= no terminales</li><li>T=Terminales</li><li>P=Producciones</li><li>S=Símbolo inicial</li></ul></li></ul></li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">   lista  -&gt; lista + digito</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   lista  -&gt; lista - digito</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   lista  -&gt; digito</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   digito -&gt; 0|1|2|3|4|5|6|7|8|9</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>   también puede agruparse de la siguiente manera:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">   lista  -&gt; lista + digito</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          | lista - digito</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          | digito</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   digito -&gt; 0|1|2|3|4|5|6|7|8|9</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>donde el &quot;|&quot; se lee como o</p><p>​    </p><h5><a aria-hidden="true" tabindex="-1" class="anchor anchor__h5 anchorWithStickyNavbar_31ik" id="gramática-para-expresiones-regulares-simples"></a>Gramática para expresiones regulares simples:<a class="hash-link" href="#gramática-para-expresiones-regulares-simples" title="Direct link to heading">#</a></h5><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">    expresion -&gt; expresion + termino  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    expresion -&gt; expresion - termino</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    expresion -&gt; termino</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    termino   -&gt; termino * factor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    termino   -&gt; termino / factor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    termino   -&gt; factor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    factor    -&gt; ( expresion )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    factor    -&gt; id</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>​    </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">    expresion -&gt; expresion + termino  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">              | expresion - termino</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              | termino</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    termino   -&gt; termino * factor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              | termino / factor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              | factor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    factor    -&gt; ( expresion )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              | id</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>​    </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">    E  -&gt; E + T | E - T | T </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    T  -&gt; T * F | T / F | F </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    F  -&gt; ( E ) | id</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="derivaciones"></a>Derivaciones<a class="hash-link" href="#derivaciones" title="Direct link to heading">#</a></h3><p>(Lou:p100) </p><p>Las reglas gramaticales determinan las cadenas legales de símbolos de token por medio de derivaciones. Una <strong>derivación</strong> es <em>una secuencia de reemplazos de nombres de estructura por selecciones en los lados derechos de reglas gramaticales</em>.</p><p>En otras palabras, (Aho:p44) <strong>una gramática deriva cadenas empezando con el símbolo inicial y sustituyendo en forma repetida un no terminal, mediante el cuerpo de una producción para ese no terminal</strong>.</p><ul><li><p>Una derivación es una construcción, en la cual se aplican las producciones de una gramática para obtener una cadena de terminales. Es decir, sustituir la variable de LHS por las del RHS.</p></li><li><p>Existen dos tipos de derivaciones:</p><ul><li>Derivación <strong>hacia la izquierda</strong>, en la que se sustituye siempre el nodo no terminal que se encuentra más a la izquierda.</li><li>Derivación <strong>hacia la derecha</strong>, en el que se sustituye siempre el nodo no terminal que se encuentra más a la derecha.</li></ul></li></ul><ol><li><p>Ejemplo:</p><p>Sea la gramática:</p></li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">   expr -&gt; expr op expr</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        | intLit</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        | id</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   op   -&gt; + | * </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>   G=( {expr,op}, {+, *, inLit, id}, P, expr )</p><p>Se quiere demostrar usando la gramática anterior que la cadena &quot; 2 + 3 * x &quot; es válida respecto a la gramática. Aplicando derivación hacia la izquierda, empezando por la primera producción que es el símbolo inicial :
expr =&gt; <em>expr</em> op expr                                     //expr  -&gt; intLit<br>
=&gt; intLit <em>op</em> expr                                         //op     -&gt; +
=&gt; intLit + <em>expr</em>                                         //expr  -&gt; expr op expr
=&gt; intLit + <em>expr</em> op expr                          //expr  -&gt; intLit
=&gt; intLit + intLit <em>op</em> expr                        //op      -&gt; <em><br>=&gt; intLit + intLit </em> <em>expr</em>                           //id       -&gt; x<br>
=&gt; intLit + intLit * id</p><p>   La serie de remplazos de arriba se denomina <strong>derivación</strong>, cada paso de la derivación reemplaza un símbolo no terminal por alguna de sus producciones alternativas.</p><ol><li><p>Árbol Sintáctico</p><p>(Moo:p37)</p><p>Teniendo en cuenta el ejemplo anterior de la misma forma puede hacerse pero para crear un árbol:</p><ul><li>Se comienza por el símbolo S, en este caso expr =&gt; expr op expr</li></ul><p><img alt="img" src="data:image/png;base64,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"></p><p>Insertando recursivamente las derivaciones faltantes se obtiene el siguiente árbol</p><p><img alt="img" src="/assets/images/parse-derivacion-total-izq-a395ae3984d37c27e5e0ca20ec8cfe6f.png"></p><p>Esta estructura se denomina <strong>Árbol Sintáctico</strong> de la gramática G, y tiene las siguientes propiedades:</p><ul><li><p>Las hojas (nodos terminales) están etiquetadas por los símbolos no terminales.</p></li><li><p>Los nodos interiores ( nodos no terminales) están etiquetados por los símbolos no terminales.</p></li><li><p>Los hijos de un nodo interior N corresponde a la regla para N, teniendo en cuenta el nivel.</p></li></ul><p>Que sucede si se elige una derivación por la izquierda utilizando otra producción, es decir expr =&gt; expr or expr // expr-&gt; expr or expr ? (hacerlo como repaso):</p><p><img alt="img" src="/assets/images/parse-derivacion-total-der-c3b1ee39ee324bdd3539e71ff6678be5.png"></p><p>Hay un claro problema, la <strong>gramática es ambigua</strong>. Una gramática es ambigua cuando produce más de una derivación por la izq o por la derecha.</p></li><li><p>Tipos  de Recursividad en las Producciones</p><ul><li><p><strong>Recursividad</strong></p><p>Al analizar la recursividad en gramáticas, y por lo tanto también en el lenguaje generado, podemos hacer una analogía con el concepto de función recursiva en el ámbito de la programación, donde una función es recursiva cuando se llama a sí misma.</p></li><li><p><strong>Producciones Recursivas</strong></p><p>Una producción es recursiva cuando el símbolo no terminal del lado izquierdo de la regla de producción, aparece también en el lado izquierdo de la misma.</p><p>Las siguientes producciones son recursivas: A → 0A1, B := BA01</p></li><li><p><strong>Producciones recursivas por izquierda</strong></p><p>Una producción es recursiva por izquierda cuando el símbolo no terminal del lado izquierdo de la regla de producción, aparece en primer lugar en el lado derecho de la misma.</p><p>Ejemplo: A → Ac</p></li><li><p><strong>Producciones recursivas por derecha</strong></p><p>Una producción es recursiva por derecha cuando el símbolo no terminal del lado izquierdo de la regla de producción, aparece en el último lugar en el lado derecho de la misma.</p><p>Por ejemplo, la siguiente producción es recursiva por derecha: B → aB</p></li></ul></li></ol><ol start="4"><li><p>Árboles</p><ol><li><p><strong>Árbol de Análisis Gramatical</strong> o Parse Tree o Árbol de Análisis Sintáctico</p><p>(lou:p109) Un árbol de análisis gramatical o árbol sintáctico de una Gramática es una representación útil de la estructura de una cadena de tokens, ya que los tokens aparecen como las hojas del árbol ( de izquierda a derecha) y los nodos internos del árbol representan los pasos dela derivación (en algún orden).</p><ul><li>Estos árboles contienen mucha información, más de la necesaria para que el compilador produzca código ejecutable.</li></ul><p><img alt="img" src="/assets/images/parse-tree-a395ae3984d37c27e5e0ca20ec8cfe6f.png"></p></li><li><p>Árbol Abstracto de Sintaxis o AST</p><p>Un árbol abstracto de sintaxis o AST contiene la información mínima para poder traducir a código ejecutable de una forma más eficiente que los arboles gramaticales.</p></li></ol></li></ol><p><img alt="img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALMAAAFbCAYAAACedL+oAAAABmJLR0QA/wD/AP+gvaeTAAASEklEQVR4nO3de1DU5d/G8WtP4EKaOgrjaQwszZA8oIF/qAg/NTwMmkoKiI1NZjSVDqSF4iEdi5mKrMbSGdPRxhwxHVMcJ89palmWpqKgdkBh1EQLUYTdvZ8/euSRRMHf4+5974frNeMf7DruNfbu7guxXyxKKQUi/5dn1b2A6EFhzCQGYyYxGDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJwZh9ICYmBnl5ebpniMeYfeDUqVM4c+aM7hniMWYvmTNnDiIiInDy5En07dsXffr0wcyZMxEaGoqysjLd80Sy8L4Z3nH+/HksW7YMBQUFqKysREREBEpKSjBs2DCMHj1a9zyJeN8Mb7Hb7bh58yYAIDAwEADgdrthtfKv3Fv4N+slS5cuxYYNG7BgwQL8+eefiI+PR/v27TFlyhSUl5frnicSLzN8oEWLFsjKysLrr7+ue4pkvMzwhUceeQSPP/647hni8WQmKXgykxyMmcRgzCQGYyYxGDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJwZhJDMZMYjDm+1RYWIhvvvnGa39+VVUVVq1aBY/H47XXkMque4C/ycrKQlFREX7++WdYLJYH/ucXFRXhueeeQ0BAAJ599tkH/udLxjsa3YdffvkFPXr0wPr165GYmOi110lJScEPP/yA48ePw27nedNAeYz5PowYMQKlpaU4dOiQV07lW4qKivDEE09g2bJlSEtL89rrCMOYG+rQoUOIjo7Gli1b8PTTT3v99SZNmoRdu3bh1KlTCAgI8PrrCcCYG2rQoEG4fv06vv32W5+83u+//47OnTvj448/xgsvvOCT1/RzjLkh9u3bh379+mHnzp0YOHCgz143PT0d+fn5KCwsrLn7Pt0VY26I2NhY2Gw27Nixw6evW1paik6dOiEnJwevvPKKT1/bD/GWtvX5+uuvsWfPHsyZM8fnr92mTRu8+OKLWLhwIa5fv+7z1/c3PJnr0bdvX7Rs2RL5+flaXv/SpUvo1KkTZs+ejczMTC0b/ARP5nv56quvcPDgQS2n8i2tW7dGeno6cnJy+IN96sGT+S6UUujVqxfCwsKwfv16rVuuXLmC8PBwZGZmYubMmVq3GIwn892sW7cOR48e1Xoq39KiRQu89tprePfdd3HlyhXdc4zFmOvg8Xgwf/58JCUloXv37rrnAACmTZsGq9WK3Nxc3VOMxZjrsHr1apw4cQKzZ8/WPaXGww8/jIyMDOTm5uLixYu65xiJ18z/4na7ERERgb59+2L58uW659RSUVGBTp06YeLEicjJydE9xzS8Zv635cuX4+zZs8jOztY95Q7BwcGYPn06PvroI5w/f173HOPwZL5NdXU1unTpgsGDB+PTTz/VPadOlZWVeOyxx/DMM89g0aJFuueYhCfz7ZYuXYqSkhKjv/zVpEkTvPHGG1iyZAmKi4t1zzEKT+b/5U8nnj/8F0QDnsy3LF68GJcvX8b06dN1T6mXw+FAVlYWPvvsM5w9e1b3HGPwZIZ/fpXA5K+6aMKTGQAWLVqEiooKZGRk6J7SYDabDbNmzcKqVatQUFCge44RGv3J/NdffyE8PBwvv/wy3nrrLd1z7ovH40GPHj0QERGBL774Qvcc3Xgy5+bmwuPxYNq0abqn3Der1Yrs7GysXbsWR44c0T1Hu0Z9Mkv4bjSTvrtPs8Z9Mufk5MBut+PVV1/VPeW/ZrFYMG/ePGzYsAHff/+97jlaNdqTWdo7OHS/I8YAjfdkXrhwIYKDg5Genq57ygMxb948bNmyxav3wTNdozyZpb7rWde7yA3ROE/m+fPno3Xr1pg8ebLuKQ/UggULsHPnTuzatUv3FC0a3cks/U5Bvr7zkkEa301gpN/Dzdf3xDOI3MuMJUuWYPPmzbUeKyoqwqpVqzBv3jyRIQNAnz59MGzYMMyaNQu3n1MVFRXIycnBTz/9pHGdlymhEhISFAAVFRWltm3bppRSKjk5WXXu3FlVV1drXuddR48eVVarVW3YsEHduHFD5ebmqpYtWyoAasWKFbrnectasTGHhYUpAMpmsykA6qmnnlJOp1OtWbNG9zSfGDVqlIqMjFShoaE1fwcBAQEqOztb9zRvWSvytuwejwfnzp0D8M+3SgLAjz/+CLfbjdzcXLRp0wb9+/fXOdFrPB4PvvzySxw6dAglJSVQStVcbrhcLpw+fVrzQu8Rec1cXFyM6urqWo/divrw4cMYMGAA4uLicPjwYR3zvMLj8SAvLw+PPvooxo0bh/Pnz8Pj8dS6bvZ4PKK/XVRkzGfOnLnrc7ci3717N/r164fCwkJfzfKqDz/8EElJSfjtt9/uiPh29/q78XciYz59+vQ9f7CNzWZDkyZNsGXLFnTu3NmHy7xn6tSpePPNN+v9feXl5WJv8SU2ZpvNVudzdrsdQUFB2LlzJwYMGODjZd61cOFCvP322/X+Pqmns8iYi4qKUFVVdcfjdrsdzZo1w969exETE6NhmffNmDEDixcvvutPw7JarWI/CRQZc0FBwR3XjA6HA61bt8aBAweMuRmit7z00ktYtWoVrFbrHVE7HA6ezP7kjz/+qPWxw+FAaGgo9u3bJ+YauT4pKSlYv3497HY7rNb/+8fscrkYs78oLS3FjRs3aj52OBzo2LEjDh48iPDwcI3LfC8xMREbN26E3W6v+RzC7XbjxIkTmpd5h7iYbz91HA4HunbtigMHDqBdu3YaV+mTkJCAbdu2ITAwsOYrPLxm9hO3Yrbb7YiKisLevXvRqlUrzav06t+/P3bu3Amn0wmLxYKysjJUVFTonvXAiYv51qkzYMAA7NixA82aNdO8yAzR0dHYu3cvWrRoAaWUyOtmcTGfOXMGiYmJyM/PR1BQkO45RunevTv279+Pdu3aibzUEBdzTEwM1q1bxx/PexddunTBvn37dM/wikb3ThMSS+47TajxYcwkBmMmMRgzicGYSQzGTGIwZhKDMZMYjJnEYMwkBmMmMRgzicGYSQzGTGIYHfOGDRsQERGBhx56CDExMdi/f7/uSWQwY2PevXs3CgsLcfDgQXz33XfweDwYMmQILl68qHsaGcrYmI8cOYIZM2agadOmiIiIwJw5c3Dt2jXRd7Gk/x9jY54yZUqtj48ePYqOHTsiOjpa06LGIzY2FhaLpebX7t27MXfu3JqPV6xYoXti3fTd6Lxhzp49q7KyslT79u3V0aNHdc9pFC5fvqymT5+uAKghQ4Yoj8ej/v77bxUSEqLWrl2rqqqqdE+si9k/BqK4uFgBUABUYGCgyszMVC6XS/esRiMlJUVZLBa1a9culZGRoTZt2qR70r2YHbNSSt24cUPt2rVLDRw4UAFQs2fP1j2p0aioqFBPPvmkat68ucrJydE9pz5r/ebd2Tdv3kSvXr3gcrlw6tQp3XMajby8PCQlJWHEiBHYuHHjXW+VawD/eXd2YGAgxowZA5fLpXtKo3Hu3Dl8/vnnWLZsGTZt2oR33nlH96R78qufNvXrr79i6NChumc0CteuXcPkyZOxdOlStG/fHgcOHEB2djb69OmD//znP7rn1U33hU5diouLVUhIiJo4caIqLCxUV69eVR988IHq3r27Kisr0z1PvIsXL6q4uDj1/vvv1zx27tw5ZbfbVYsWLdSOHTuU2+3WuLBOZn4CeO3aNTV48GAVFBSknE6nioyMVHPnzlXl5eW6pzUKiYmJNV9FKi0tVUopFR8fX/MYgJqfemsQ//kEkKge/vMJIFF9GDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJYXzMFy5cwPbt23XPID9gfMx79uzBoEGDdM8gP2B8zEQNxZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYx7LoH3K6kpATDhw9HdXV1zWPl5eUICAhAZGRkrd/bs2dPrFy50tcTyWBGxdy2bVtUVVXh+PHjdzx37NixWh+PGzfOV7PITxh3mZGWlga7/d7/jlksFiQnJ/toEfkL42IeP3483G73XZ+3WCyIiopCWFiYD1eRPzAu5g4dOiA6OhpWa93TbDYb0tLSfLyK/IFxMQPAhAkTYLFY6nzO4/EgKSnJx4vIHxgZ891itdlsiI2NRWhoqI8XkT8wMuZWrVohPj4eNpvtjucmTJigYRH5AyNjBoDU1FQopWo9ZrVaMXLkSE2LyHTGxjxy5Eg4HI6aj+12O4YNG4bmzZtrXEUmMzbmpk2bYsSIETVBu91upKamal5FJjM2ZgBISUmBy+UCADidTgwdOlTzIjKZ0TEnJCQgODgYADB69Gg4nU7Ni8hkRsccGBiIsWPHAvjnlCa6F6NjBoDk5GSEhIQgPj5e9xQynPExx8XFYerUqfV+8xGRRf37i7kGcrlcjJnqk2f8yQyAIVOD+EXMRA3BmEkMxkxiMGYSgzGTGIyZxGDMJAZjJjEYM4nBmEkMxkxiMGYSgzGTGEbHXFlZieHDh+ueQX7C6JiJ7gdjJjEYM4nBmEkMo2IeN24cLBZLzS+n04n8/Pxaj1ksFqxZs0b3VDKQ0W9oraysxJgxY7B582bdU8h8/vGGVqKGYMwkBmMmMRgziWH0J4BE94GfAJIcjJnEYMwkBmMmMRgzicGYSQzGTGIwZhKDMZMYjJnEYMwkBmMmMRgzicGYSQzGTGIwZhKDMZMYjJnEYMwkhvExX7hwAdu3b9c9g/yA8THv2bMHgwYN0j2D/IDxMRM1FGMmMRgzicGYSQzGTGIwZhKDMZMYjJnEYMwkBmMmMRgzicGYSQzGTGIwZhKDMZMYjJnEYMwkBmMmMRgzicGYSQzGTGIwZhKDMZMYjJnEYMwkBmMmMRgzicGYSQzGTGIwZhKDMZMYjJnEsOsecLuSkhIMHz4c1dXVNY+Vl5cjICAAkZGRtX5vz549sXLlSl9PJIMZFXPbtm1RVVWF48eP3/HcsWPHan08btw4X80iP2HcZUZaWhrs9nv/O2axWJCcnOyjReQvjIt5/PjxcLvdd33eYrEgKioKYWFhPlxF/sC4mDt06IDo6GhYrXVPs9lsSEtL8/Eq8gfGxQwAEyZMgMViqfM5j8eDpKQkHy8if2BkzHeL1WazITY2FqGhoT5eRP7AyJhbtWqF+Ph42Gy2O56bMGGChkXkD4yMGQBSU1OhlKr1mNVqxciRIzUtItMZG/PIkSPhcDhqPrbb7Rg2bBiaN2+ucRWZzNiYmzZtihEjRtQE7Xa7kZqaqnkVmczYmAEgJSUFLpcLAOB0OjF06FDNi8hkRseckJCA4OBgAMDo0aPhdDo1LyKTGR1zYGAgxo4dC+CfU5roXoyOGQCSk5MREhKC+Ph43VPIcMbHHBcXh6lTp9b7zUdEFvXvL+YayOVyMWaqT57xJzMAhkwN4hcxEzUEYyYxGDOJwZhJDMZMYjBmEoMxkxiMmcRgzCQGYyYxGDOJwZhJDMZMYhgb882bN5GdnY2wsDAEBwcjMjISn3zyyR23HyC6xdiYMzIyEB4ejiNHjuDkyZPo3bs30tPTMWPGDN3TyFBGfnP+pUuXsHXr1lp3L/J4POjWrRuuXr2KkpISjevIUHlGftd769at77gNl9VqRdeuXXH+/HlNq8h0xl5m1KWgoADPP/+87hlkKL+Jed++fbDb7Zg0aZLuKWQov4i5uroaWVlZWL16dZ13BiUC/CTmzMxMZGRkoFu3brqnkMGMjzk3NxexsbFITEyseczAL8CQAYyOec2aNejduzdGjRoF4J/LjT179mDBggWal5GJjPzSHAAsWLAA2dnZdT63detWH68hf2Dk/zR57733kJmZWedzQUFBKCsrQ2BgoI9XkeHyjIyZ6L/gH7fnImoIxkxiMGYSgzGTGIyZxGDMJAZjJjEYM4nBmEkMxkxiMGYSgzGTGIyZxGDMJAZjJjEYM4nBmEkMxkxiMGYSgzGTGIyZxGDMJAZjJjHsAPJ0jyB6AA7+DwkKfwRLNVAmAAAAAElFTkSuQmCC"></p><p>Es una representación abstracta de la secuencia de tokens del código fuente real, estas secuencias no se pueden recobrar a partir de ellas.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="nomenclatura-de-analizadores-sintácticos"></a>Nomenclatura de Analizadores Sintácticos<a class="hash-link" href="#nomenclatura-de-analizadores-sintácticos" title="Direct link to heading">#</a></h3><p>Los parsers se nombran según :</p><ul><li><p>La dirección de parse:</p><ul><li>L: Parseo de Izquierda a derecha (<strong>Parse from Left to right</strong>)</li><li>R: Parseo de Derecha a izquierda (<strong>Parse from Right to Left</strong>)</li></ul></li><li><p>La resolución de las derivaciones</p><ul><li>L: Derivacion hacia la izquierda (<strong>Left most derivation</strong>)</li><li>R: Derivación hacia la derecha (<strong>Right most derivation</strong>)</li></ul></li><li><p>El símbolo de entrada de anticipacón o Lookahead Es la cantidad de simbolos de entrada de anticipacion , patra tomar decisiones de acción del analisis sintáctico.</p></li></ul><p>Entonces <strong>LL(1)</strong> es un analizador sintáctico que parsea de Izquierda a derecha, con derivaciones hacia izquierda con 1 caracter de anticipación.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="tipos-de-analizadores-sintácticos"></a>Tipos de Analizadores Sintácticos<a class="hash-link" href="#tipos-de-analizadores-sintácticos" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor anchor__h4 anchorWithStickyNavbar_31ik" id="analizadores-sintácticos-de-descendiente-recursivo"></a>Analizadores Sintácticos de Descendiente Recursivo<a class="hash-link" href="#analizadores-sintácticos-de-descendiente-recursivo" title="Direct link to heading">#</a></h4><p>(lou:p143)</p><p>El algoritmo del análisis sintáctico <strong>descendente</strong> analiza una cadena de tokens de entrada mediante la búsqueda de las producciones o pasos de derivación por izquierda. El algoritmo se denomina así debido a que el recorrido implicado del árbol de análisis gramatical es un recorrido en <strong>pre-orden</strong> , y de ese modo se presenta desde la raíz hacia las hojas.</p><p>Puede verse como el problema de construir un árbol de análisis sintáctico para la cadena de entrada , partiendo del nodo raíz y creando los nodos del árbol sintáctico en pre-orden (Aho:p217).</p><ul><li>En cada paso de un análisis sintáctico descendente, el problema clave es el de determinarla producción que debe aplicarse para un no terminal.</li></ul><ol><li><p>Ejemplo 1</p><p>(tiger:p47)</p><p>Sea la siguiente gramática:</p></li></ol><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">    S -&gt; if E then S else S </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    S -&gt; begin S L</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    S -&gt; print E</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    L -&gt; end </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    L -&gt; S L </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    E -&gt; num = num </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>A continuación se genera un parser para la gramática anterior aplicando el algoritmo conocido como recursivo descendente. Este tiene una sola función por cada símbolo no terminal y una clausula para cada producción:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><pre tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">    enum token {IF, THEN, ELSE, BEGIN, END, PRINT, PUNTOYCOMA, NUMERO, IGUAL};</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    extern enum token get_token(void);  // yylex()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum token tok;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void avanzar(){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        tok=get_token();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void consumir (enum token t){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tok=t) avanzar();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        else error();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void S (void){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        switch(tok){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        case IF: </span></span><span class="token-line" style="color:#393A34"><span class="token plain">         consumit(IF); E(); consumir(THEN); S();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    consumir(ELSE); S();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         breack;  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        case BEGIN:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         consumir(BEGIN); S(), L();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         breack;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        case PRINT: </span></span><span class="token-line" style="color:#393A34"><span class="token plain">         consumir(PRINT); E();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        default: </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        error();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void L (void){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        switch (tok){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        case END:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            consumir(END);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        case PUNTOYCOMA:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            consumir(PUNTOYCOMA); S(); L();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        default:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        error();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void E (void){</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        consumir(NUM); consumir(IGUAL); consumir(NUM);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>Con get_token() y error(); andando este fragmento de código funciona perfectamente.</p><p>Intentar realizar lo mismo para la siguiente gramatica:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">    S -&gt; E$</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    E -&gt; E + T </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    E -&gt; E - T </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    E -&gt; T</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    T -&gt; T * F</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    T -&gt; T / F </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    T -&gt; F</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    F -&gt; id</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    F -&gt; num</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    F -&gt; (E)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>El análisis sintáctico de descenso recursivo, o predictivo, solo funciona en gramáticas donde el primer símbolo terminal de cada sub-expresión provee suficiente información para elegir que producción usar.</p></div><footer class="docusaurus-mt-lg"><div class="row"><div class="col"><a href="https://github.com/compiladores/compiladores.github.io/edit/master/docs/versioned_docs/version-2021_2/teoricas/04-analisis-sintactico/01-intro.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/2021_2/teoricas/analisis-lexico/analisis-lexico"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Generadores de Analizadores Léxicos</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/2021_2/teoricas/analisis-sintactico/LL1"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Analizadores Sintácticos LL(1) »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#el-proceso-de-análisis-sintáctico" class="table-of-contents__link">El Proceso de Análisis Sintáctico</a></li><li><a href="#introducción-gramáticas" class="table-of-contents__link">Introducción Gramáticas</a></li><li><a href="#gramáticas-libres-de-contexto" class="table-of-contents__link">Gramáticas Libres de Contexto</a></li><li><a href="#derivaciones" class="table-of-contents__link">Derivaciones</a></li><li><a href="#nomenclatura-de-analizadores-sintácticos" class="table-of-contents__link">Nomenclatura de Analizadores Sintácticos</a></li><li><a href="#tipos-de-analizadores-sintácticos" class="table-of-contents__link">Tipos de Analizadores Sintácticos</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Material</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/labs/intro">Laboratorios</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Hecho para Ud.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8063297e.js"></script>
<script src="/assets/js/main.93dbc1f3.js"></script>
</body>
</html>
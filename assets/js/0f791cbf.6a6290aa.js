"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4041],{3905:function(e,a,n){n.d(a,{Zo:function(){return c},kt:function(){return m}});var t=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=t.createContext({}),p=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},c=function(e){var a=p(e.components);return t.createElement(s.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},u=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,k=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?t.createElement(k,o(o({ref:a},c),{},{components:n})):t.createElement(k,o({ref:a},c))}));function m(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1921:function(e,a,n){n.r(a),n.d(a,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var t=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={},s="Laboratorio 3",p={unversionedId:"labs/Laboratorio 3",id:"version-2021_2/labs/Laboratorio 3",isDocsHomePage:!1,title:"Laboratorio 3",description:"Introducci\xf3n",source:"@site/versioned_docs/version-2021_2/labs/Laboratorio 3.md",sourceDirName:"labs",slug:"/labs/Laboratorio 3",permalink:"/docs/2021_2/labs/Laboratorio 3",editUrl:"https://github.com/compiladores/compiladores.github.io/edit/master/docs/versioned_docs/version-2021_2/labs/Laboratorio 3.md",tags:[],version:"2021_2",frontMatter:{},sidebar:"version-2021_2/tutorialSidebar",previous:{title:"Parte 6 (2 horas)",permalink:"/docs/2021_2/labs/Laboratorio 2/parte6"},next:{title:"intro",permalink:"/docs/2021_2/labs/intro"}},c=[{value:"Introducci\xf3n",id:"introducci\xf3n",children:[]},{value:"Contenido del esqueleto",id:"contenido-del-esqueleto",children:[]},{value:"Parte 1: lexer (2 horas)",id:"parte-1-lexer-2-horas",children:[{value:"Defectos de la parte 1",id:"defectos-de-la-parte-1",children:[]},{value:"Consigna",id:"consigna",children:[]},{value:"Consejos importantes",id:"consejos-importantes",children:[]}]},{value:"Parte 2: funciones (2 horas)",id:"parte-2-funciones-2-horas",children:[{value:"Consigna",id:"consigna-1",children:[]}]},{value:"Parte 3: funciones de listas (1 hora)",id:"parte-3-funciones-de-listas-1-hora",children:[{value:"Consigna",id:"consigna-2",children:[]}]},{value:"Parte 4 (3 horas)",id:"parte-4-3-horas",children:[{value:"Consigna",id:"consigna-3",children:[]}]},{value:"Parte 5 (1.5 horas)",id:"parte-5-15-horas",children:[{value:"Consigna",id:"consigna-4",children:[]}]},{value:"Parte 6 (1.5 horas)",id:"parte-6-15-horas",children:[{value:"Consigna",id:"consigna-5",children:[]}]},{value:"Parte 7 (1.5 horas)",id:"parte-7-15-horas",children:[{value:"Consigna",id:"consigna-6",children:[]}]}],d={toc:c};function u(e){var a=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,t.Z)({},d,n,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"laboratorio-3"},"Laboratorio 3"),(0,i.kt)("h2",{id:"introducci\xf3n"},"Introducci\xf3n"),(0,i.kt)("p",null,"En este laboratorio realizaremos un int\xe9rprete de una parte peque\xf1a del lenguaje Scheme r5rs, definido en ",(0,i.kt)("a",{parentName:"p",href:"https://schemers.org/Documents/Standards/R5RS/r5rs.pdf"},"este pdf"),". La fracci\xf3n que implementaremos de r5rs es \xednfima, pero el st\xe1ndard citado incluye una gram\xe1tica y una sem\xe1ntica formal, lo cual puede ser de mucha ayuda para escribir la gram\xe1tica. Este texto no incluye una definici\xf3n de la gram\xe1tica y la sem\xe1ntica sino que se proveen tests como parte del esqueleto. Estos servir\xe1n como una especificaci\xf3n informal de la fracci\xf3n de r5rs que se debe implementar."),(0,i.kt)("h2",{id:"contenido-del-esqueleto"},"Contenido del esqueleto"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Proyecto java y devcontainer configurados"),(0,i.kt)("li",{parentName:"ul"},"Un archivo ",(0,i.kt)("inlineCode",{parentName:"li"},"jflex")," con el contenido m\xednimo para que el proyecto compile (debe completarse en la parte 1)"),(0,i.kt)("li",{parentName:"ul"},"Una gram\xe1tica de bison que tiene la definici\xf3n de ",(0,i.kt)("inlineCode",{parentName:"li"},"datum")," ","[r5rs 7.1.2]"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LexerHelper.java")," permite integrar bison y jflex"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ParserHelper"),": La clase generada por bison hereda de esta, entonces desde el archivo bison se pueden llamar a sus m\xe9todos."),(0,i.kt)("li",{parentName:"ul"},"Carpeta ",(0,i.kt)("inlineCode",{parentName:"li"},"value"),": Contiene la definici\xf3n de la clase abstracta ",(0,i.kt)("inlineCode",{parentName:"li"},"SemVal")," y sus hijas, que representan valores sem\xe1nticos de bison. Incluye adem\xe1s una interfaz para un visitor, y un extractor que permite obtener el valor interno de cualquier ",(0,i.kt)("inlineCode",{parentName:"li"},"SemVal")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Displayer.java"),": Visitor que convierte valores de nuestro scheme en un string."),(0,i.kt)("li",{parentName:"ul"},"Suite de tests: Consiste en un archivo que utiliza los ",(0,i.kt)("inlineCode",{parentName:"li"},"ParameterizedTest")," de JUnit para ejecutar los tests que se encuentran en la carpeta ",(0,i.kt)("inlineCode",{parentName:"li"},"resources"),". A cada parte del laboratorio le corresponde uno o m\xe1s de estos archivos csv. Estos archivos no deben ser modificados (ni los ",(0,i.kt)("inlineCode",{parentName:"li"},".csv")," ni los ",(0,i.kt)("inlineCode",{parentName:"li"},".java"),"). De ser necesario agregar tests, hacerlo en archivos nuevos. ",(0,i.kt)("strong",{parentName:"li"},"Todos los dem\xe1s archivos se pueden modificar a gusto, el esqueleto se provee como una ayuda."))),(0,i.kt)("h2",{id:"parte-1-lexer-2-horas"},"Parte 1: lexer (2 horas)"),(0,i.kt)("p",null,"El documento que describe ",(0,i.kt)("inlineCode",{parentName:"p"},"r5rs")," utiliza la notaci\xf3n EBNF para describir los tokens y las reglas gramaticales. El archivo ",(0,i.kt)("inlineCode",{parentName:"p"},".y")," ya incluye algunas reglas gramaticales, las cuales inducen un conjunto de tokens. Dado que el parser ya incluye las reglas necesarias para que funcione ",(0,i.kt)("inlineCode",{parentName:"p"},"1.quotation.csv")," (",(0,i.kt)("em",{parentName:"p"},"datum"),"), basta completar ",(0,i.kt)("inlineCode",{parentName:"p"},"CompischemeLexer.jflex"),"."),(0,i.kt)("p",null,"Concretamente, en esta primera parte debe describirse en el archivo ",(0,i.kt)("inlineCode",{parentName:"p"},"jflex")," todos los tokens que vienen declarados en el archivo ",(0,i.kt)("inlineCode",{parentName:"p"},".y"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"%token QUOTE\n%token ABBREV_QUOTE\n%token QUASIQUOTE\n%token ABBREV_QUASIQUOTE\n%token LPAREN\n%token RPAREN\n%token HASH_LPAREN\n%token COMMA\n%token COMMA_AT\n%token DOT\n%token IDENTIFIER\n%token BOOLEAN\n%token NUMBER\n%token CHARACTER\n%token STRING\n")),(0,i.kt)("p",null,"Para saber qu\xe9 expresi\xf3n regular vincular a cada tipo de token, se debe revisar la secci\xf3n 7.1 de ",(0,i.kt)("a",{parentName:"p",href:"https://schemers.org/Documents/Standards/R5RS/r5rs.pdf"},"la especificaci\xf3n r5rs"),". El archivo ",(0,i.kt)("inlineCode",{parentName:"p"},".y")," es una traducci\xf3n casi literal del contenido de la secci\xf3n 7.1. Las reglas gramaticales tienen el mismo nombre en el archivo ",(0,i.kt)("inlineCode",{parentName:"p"},".y")," del esqueleto y en la especificaci\xf3n."),(0,i.kt)("h3",{id:"defectos-de-la-parte-1"},"Defectos de la parte 1"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"hubo una confusi\xf3n con la ",(0,i.kt)("inlineCode",{parentName:"li"},"quasiquotation"),", puede eliminarse del archivo ",(0,i.kt)("inlineCode",{parentName:"li"},".jflex"),"."),(0,i.kt)("li",{parentName:"ul"},"record\xe1 agregar la regla para detectar espacios, ya que sin eso se reciben errores de sintaxis todo el tiempo.")),(0,i.kt)("h3",{id:"consigna"},"Consigna"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Completar con el contenido m\xednimo posible el archivo ",(0,i.kt)("inlineCode",{parentName:"strong"},"CompischemeLexer.jflex")," de forma que el test que ejecuta ",(0,i.kt)("inlineCode",{parentName:"strong"},"1.quotation.csv")," tenga un resultado positivo.")),(0,i.kt)("h3",{id:"consejos-importantes"},"Consejos importantes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"No separar como tokens todos los ",(0,i.kt)("em",{parentName:"li"},"keywords")," del lenguaje r5rs, sino unicamente los necesarios para que pase el test. Los dem\xe1s tokens se a\xf1aden en las siguientes partes."),(0,i.kt)("li",{parentName:"ul"},"JFlex prioriza las reglas seg\xfan su orden de aparici\xf3n en el archivo, con lo cual no es necesario tener los tokens ",(0,i.kt)("em",{parentName:"li"},"variable")," e ",(0,i.kt)("em",{parentName:"li"},"identifier")," separados tal como figuran en r5rs. Todas las variables son identifier.")),(0,i.kt)("h2",{id:"parte-2-funciones-2-horas"},"Parte 2: funciones (2 horas)"),(0,i.kt)("p",null,"Para hacer que pasen los tests cuyos archivos csv inician con el n\xfamero 2, se deben a\xf1adir al parser las reglas ",(0,i.kt)("em",{parentName:"p"},"procedure call")," y ",(0,i.kt)("em",{parentName:"p"},"variable")," (r5rs 7.1.3). Se recomienda capturar las variables como un subtipo de ",(0,i.kt)("inlineCode",{parentName:"p"},"SemVal")," separado, pero no incluir ningun tipo de gesti\xf3n de contexto a\xfan (se recomienda hacerlo en la parte 6): el m\xe9todo que capture la regla ",(0,i.kt)("em",{parentName:"p"},"procedure call")," puede simplemente buscar el nombre de la funci\xf3n invocada (",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"equals"),", etc.) en un diccionario. Se recomienda, adem\xe1s, no implementar a\xfan un ",(0,i.kt)("inlineCode",{parentName:"p"},"SemVal")," que almacene la invocaci\xf3n a una funci\xf3n, sino hacer que el parser devuelva el ",(0,i.kt)("inlineCode",{parentName:"p"},"SemVal")," que la ejecuci\xf3n tiene como resultado."),(0,i.kt)("p",null,"Concretamente, en esta parte se recomienda que realicen las siguientes tareas:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Hace falta implementar ",(0,i.kt)("em",{parentName:"li"},"variable")," porque, si no, el parser va a detectar un error de sintaxis al encontrarse con los nombres de funciones. En r5rs, las funciones de la librer\xeda est\xe1ndard son variables."),(0,i.kt)("li",{parentName:"ol"},"Capturar la sintaxis del tipo de expresi\xf3n ",(0,i.kt)("em",{parentName:"li"},"procedure call"),". ",(0,i.kt)("em",{parentName:"li"},"procedure call")," se debe derivar de ",(0,i.kt)("em",{parentName:"li"},"expression"),", tal como en r5rs, y debe ser una regla aparte porque adentro de una ",(0,i.kt)("em",{parentName:"li"},"procedure call")," hay varias ",(0,i.kt)("em",{parentName:"li"},"expression"),"."),(0,i.kt)("li",{parentName:"ol"},"crear un m\xe9todo en el ",(0,i.kt)("inlineCode",{parentName:"li"},"ParserHelper")," que reciba la funci\xf3n invocada y sus argumentos. Esta funci\xf3n se debe invocar desde el archivo ",(0,i.kt)("inlineCode",{parentName:"li"},".y"),", y debe ser la acci\xf3n de la regla ",(0,i.kt)("em",{parentName:"li"},"procedure call"),"."),(0,i.kt)("li",{parentName:"ol"},"Implementar cada una de las funciones para hacer pasar los tests. ",(0,i.kt)("strong",{parentName:"li"},"Se recomienda no iniciar por la funci\xf3n equal sino por las matem\xe1ticas o las binarias"),".")),(0,i.kt)("h3",{id:"consigna-1"},"Consigna"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Hacer que los test que ejecutan ",(0,i.kt)("inlineCode",{parentName:"strong"},"2.1.equality.csv"),", ",(0,i.kt)("inlineCode",{parentName:"strong"},"2.2.bool.csv")," y ",(0,i.kt)("inlineCode",{parentName:"strong"},"2.3.maths.csv")," tengan un resultado positivo.")),(0,i.kt)("h2",{id:"parte-3-funciones-de-listas-1-hora"},"Parte 3: funciones de listas (1 hora)"),(0,i.kt)("p",null,"A partir del trabajo realizado en la parte 2, agregar funciones de listas. Si bien ",(0,i.kt)("inlineCode",{parentName:"p"},"ListSemVal.java")," est\xe1 implementado usando un ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),", puede ser una buena decisi\xf3n reemplazar esa implementaci\xf3n por una que utilice el concepto de ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Cons"},"cons cell"),", es decir, implementarlas usando pares ordenados. No deber\xeda ser necesario agregar nuevas reglas en el archivo bison para hacer pasar los tests de la parte 3."),(0,i.kt)("h3",{id:"consigna-2"},"Consigna"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Hacer que los test que ejecutan ",(0,i.kt)("inlineCode",{parentName:"strong"},"3.1.lists.csv"),", ",(0,i.kt)("inlineCode",{parentName:"strong"},"3.2.lists.core.csv")," y ",(0,i.kt)("inlineCode",{parentName:"strong"},"2.3.maths.csv")," tengan un resultado positivo.")),(0,i.kt)("h2",{id:"parte-4-3-horas"},"Parte 4 (3 horas)"),(0,i.kt)("p",null,"Esta parte consiste en la adici\xf3n de efectos secundarios. Para esto se deben a\xf1adir dos nuevos tipos de expressiones: ",(0,i.kt)("inlineCode",{parentName:"p"},"set!")," y ",(0,i.kt)("inlineCode",{parentName:"p"},"begin"),". La expresi\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"set!")," asigna variables, y la expresi\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"begin")," eval\xfaa expresiones en secuencia. Para poder ejecutar ",(0,i.kt)("inlineCode",{parentName:"p"},"begin")," hay que distinguir la etapa de parsing y la etapa de evaluaci\xf3n. La ",(0,i.kt)("em",{parentName:"p"},"procedure call")," ahora debe ser ",(0,i.kt)("em",{parentName:"p"},"lazy"),", es decir, debe capturar un c\xf3mputo que se realizar\xe1 en el futuro, pero no llevarlo a cabo. A partir de ahora, leer un ",(0,i.kt)("inlineCode",{parentName:"p"},"SemVal")," debe ser distinto de ",(0,i.kt)("em",{parentName:"p"},"evaluar")," o ",(0,i.kt)("em",{parentName:"p"},"ejecutar")," un ",(0,i.kt)("inlineCode",{parentName:"p"},"SemVal"),"."),(0,i.kt)("p",null,"Recomendamos encarar esta parte en dos etapas:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Primero realizar un refactor")," que separe la lectura y la ejecuci\xf3n. Usar los tests de partes anteriores para verificar que todo sigue funcionando. La ejecuci\xf3n debe tener acceso a un contexto, de forma que ",(0,i.kt)("inlineCode",{parentName:"li"},"set!")," pueda hacer algo."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Luego, implementar las instrucciones nuevas"))),(0,i.kt)("p",null,"Por ahora se debe implementar un \xfanico contexto global. La implementaci\xf3n de scopes se har\xe1 en otra etapa."),(0,i.kt)("h3",{id:"consigna-3"},"Consigna"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Hacer que los test que ejecutan ",(0,i.kt)("inlineCode",{parentName:"strong"},"4.begin.set.csv")," tengan un resultado positivo.")),(0,i.kt)("h2",{id:"parte-5-15-horas"},"Parte 5 (1.5 horas)"),(0,i.kt)("p",null,"Aprovechando la captura de expresiones en de la parte 4, implementar ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," y ",(0,i.kt)("inlineCode",{parentName:"p"},"repeat"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," no es una funci\xf3n porque s\xf3lo se eval\xfaa una rama, lo cual implica que s\xf3lo los efectos secundarios de la rama correcta deben ejecutarse. ",(0,i.kt)("inlineCode",{parentName:"p"},"repeat")," repite la ejecuci\xf3n del segundo par\xe1metro seg\xfan indique el primer par\xe1metro."),(0,i.kt)("h3",{id:"consigna-4"},"Consigna"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Hacer que los test que ejecutan ",(0,i.kt)("inlineCode",{parentName:"strong"},"5.if.csv")," y ",(0,i.kt)("inlineCode",{parentName:"strong"},"5.repeat.csv")," tengan un resultado positivo.")),(0,i.kt)("h2",{id:"parte-6-15-horas"},"Parte 6 (1.5 horas)"),(0,i.kt)("p",null,"La sem\xe1ntica relacionada a los tests de la parte 6 se encuentra en r5rs 4.2.2. Esta etapa consiste en la adici\xf3n de ",(0,i.kt)("em",{parentName:"p"},"scopes")," o ",(0,i.kt)("em",{parentName:"p"},"contextos"),", para eso es necesario modificar el algoritmo de evaluaci\xf3n extra\xeddo en la parte 4 para que reciba adicionalmente un ",(0,i.kt)("em",{parentName:"p"},"contexto"),', que se debe poder variar de alguna forma, o pasar como par\xe1metro. En esta etapa debe surgir una clase que represente el concepto de "contexto" que debe poder apuntar a su contexto envolvente, para poder utilizarlo de "fallback": En caso de que una variable no est\xe9 en cierto contexto, hay que ir a buscarla al contexto envolvente. Se recomienda que esta nueva clase tenga los siguientes m\xe9todos:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"get"),(0,i.kt)("li",{parentName:"ul"},"set"),(0,i.kt)("li",{parentName:"ul"},"bind")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"let")," y ",(0,i.kt)("inlineCode",{parentName:"p"},"let*")," tienen una sem\xe1ntica especial: ",(0,i.kt)("inlineCode",{parentName:"p"},"let*")," funciona como un listado de asignaciones de cualquier lenguaje de programaci\xf3n, pero ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," excluye del contexto de ejecuci\xf3n de las asignaciones a las dem\xe1s variables asignadas en el mismo ",(0,i.kt)("inlineCode",{parentName:"p"},"let"),". Es decir, si un ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," asigna ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," y luego ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", ",(0,i.kt)("strong",{parentName:"p"},"no")," tendr\xe1 ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," disponible al asignar ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", mientras que para ",(0,i.kt)("inlineCode",{parentName:"p"},"let*")," esto ",(0,i.kt)("strong",{parentName:"p"},"s\xed")," se cumple."),(0,i.kt)("h3",{id:"consigna-5"},"Consigna"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Hacer que el test que ejecuta ",(0,i.kt)("inlineCode",{parentName:"strong"},"6.let.csv")," tenga un resultado positivo.")),(0,i.kt)("h2",{id:"parte-7-15-horas"},"Parte 7 (1.5 horas)"),(0,i.kt)("p",null,"En esta parte se debe implementar ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda"),", que permite crear nuevas funciones. Su sem\xe1ntica est\xe1 descripta en r5rs 4.1.4, pero no debe implementarse completa. Es importante definir, en caso de que no exista a\xfan, una clase que represente funciones. Las funciones ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"equal?"),", etc, deben ser valores de este tipo, almacenados en un contexto de ejecuci\xf3n que es el m\xe1s exterior de todos (o ",(0,i.kt)("em",{parentName:"p"},"global"),"). Cuando el parser encuentra una expresi\xf3n ",(0,i.kt)("inlineCode",{parentName:"p"},"lambda"),", debe crear un nuevo ",(0,i.kt)("inlineCode",{parentName:"p"},"SemVal")," que almacene el lambda. Cuando se eval\xfaa el lambda, se debe devolver una instancia de la misma clase que la obtenida al evaluar las variables ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"equal?"),", etc."),(0,i.kt)("p",null,"As\xed, es importante reconocer la diferencia entre una ",(0,i.kt)("em",{parentName:"p"},"funci\xf3n")," y un ",(0,i.kt)("em",{parentName:"p"},"lambda"),": el resultado de la evaluaci\xf3n del ",(0,i.kt)("em",{parentName:"p"},"lambda")," es una ",(0,i.kt)("em",{parentName:"p"},"funci\xf3n"),"."),(0,i.kt)("p",null,"La ",(0,i.kt)("em",{parentName:"p"},"funci\xf3n")," creada por un ",(0,i.kt)("em",{parentName:"p"},"lambda")," se ejecuta en el contexto de ejecuci\xf3n original del ",(0,i.kt)("em",{parentName:"p"},"lambda"),", independientemente de d\xf3nde sea invocada. A este contexto se le llama ",(0,i.kt)("em",{parentName:"p"},"cierre")," (en ingl\xe9s ",(0,i.kt)("em",{parentName:"p"},"closure"),"). En el test ",(0,i.kt)("inlineCode",{parentName:"p"},"complexTest")," se crean dos funciones que act\xfaan sobre una variable ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),", que queda oculta pero a\xfan existe."),(0,i.kt)("h3",{id:"consigna-6"},"Consigna"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Hacer que el test que ejecuta ",(0,i.kt)("inlineCode",{parentName:"strong"},"7.lambda.csv")," y ",(0,i.kt)("inlineCode",{parentName:"strong"},"complextTest")," tengan un resultado positivo.")))}u.isMDXComponent=!0}}]);